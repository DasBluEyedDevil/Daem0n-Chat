---
phase: 02-user-profiles-multi-user
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - daem0nmcp/dreaming/strategies.py
  - daem0nmcp/dreaming/persistence.py
  - daem0nmcp/dreaming/scheduler.py
  - daem0nmcp/active_context.py
  - daem0nmcp/communities.py
  - daem0nmcp/entity_manager.py
  - daem0nmcp/cognitive/simulate.py
  - daem0nmcp/cognitive/debate.py
  - daem0nmcp/cognitive/evolve.py
  - daem0nmcp/similarity.py
  - tests/test_user_isolation.py
autonomous: true

must_haves:
  truths:
    - "Dreaming never creates relationships between memories belonging to different users"
    - "Active context items are scoped to the current user"
    - "Community detection operates within a single user's memories"
    - "Entity extraction and resolution is per-user"
    - "TF-IDF search results are filtered to the current user before returning"
    - "Comprehensive tests prove no cross-user memory leakage in any query path"
  artifacts:
    - path: "daem0nmcp/dreaming/strategies.py"
      provides: "User-scoped dream strategies"
      contains: "user_name"
    - path: "daem0nmcp/active_context.py"
      provides: "User-scoped active context"
      contains: "user_name"
    - path: "daem0nmcp/communities.py"
      provides: "User-scoped community detection"
      contains: "user_name"
    - path: "tests/test_user_isolation.py"
      provides: "Cross-user isolation test suite"
      contains: "test_isolation"
  key_links:
    - from: "daem0nmcp/dreaming/strategies.py"
      to: "daem0nmcp/memory.py"
      via: "Dream strategies pass user_name to recall()"
      pattern: "user_name"
    - from: "daem0nmcp/active_context.py"
      to: "daem0nmcp/models.py"
      via: "ActiveContextItem.user_name filter"
      pattern: "ActiveContextItem.*user_name"
    - from: "tests/test_user_isolation.py"
      to: "daem0nmcp/memory.py"
      via: "Tests create memories for user_A and user_B, verify isolation"
      pattern: "user_name.*user_A.*user_B"
---

<objective>
Sweep every remaining memory query path in the codebase to add user_name filtering, ensuring complete per-user isolation. This covers dreaming, active context, communities, entity management, cognitive modules, and TF-IDF post-filtering. Then verify with comprehensive isolation tests.

Purpose: Plan 01 added user_name to the core (remember/recall). This plan catches every other code path that touches memories directly -- the "leakage" prevention layer. Without this, dreaming could cross-pollinate users, communities could mix users, and active context could bleed.

Output: Complete user isolation across all subsystems, proven by tests
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-user-profiles-multi-user/02-RESEARCH.md
@.planning/phases/02-user-profiles-multi-user/02-01-SUMMARY.md

@daem0nmcp/dreaming/strategies.py
@daem0nmcp/active_context.py
@daem0nmcp/communities.py
@daem0nmcp/entity_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add user_name filtering to dreaming, active context, communities, entities, and cognitive modules</name>
  <files>
    daem0nmcp/dreaming/strategies.py
    daem0nmcp/dreaming/persistence.py
    daem0nmcp/dreaming/scheduler.py
    daem0nmcp/active_context.py
    daem0nmcp/communities.py
    daem0nmcp/entity_manager.py
    daem0nmcp/cognitive/simulate.py
    daem0nmcp/cognitive/debate.py
    daem0nmcp/cognitive/evolve.py
    daem0nmcp/similarity.py
  </files>
  <action>
**Methodology:** For each file, find every `select(Memory)`, `select(func.count(Memory.id))`, `session.execute()`, and `memory_manager.recall()` call. Add `Memory.user_name == user_name` to WHERE clauses and pass `user_name` to recall() calls.

**1. dreaming/strategies.py:**
   - All dream strategies (FailedDecisionReview, ConnectionDiscovery, CommunityRefresh, PendingOutcomeResolver, etc.) query memories. Each strategy method should accept a `user_name` parameter.
   - Add `Memory.user_name == user_name` filter to every `select(Memory)` query.
   - When calling `memory_manager.recall()`, pass `user_name=user_name`.
   - When creating new memories via dreaming (consolidation, dream insights), set `user_name=user_name`.

**2. dreaming/persistence.py:**
   - When storing dream results as memories, set `user_name=user_name` on the new Memory objects.
   - When querying for existing dream memories, filter by `user_name`.

**3. dreaming/scheduler.py:**
   - The dream scheduler should iterate per-user. Read distinct user_names from the memories table, then run dream strategies for each user separately.
   - If the scheduler runs strategies in a loop, add the user_name dimension: `for user_name in known_users: run_strategies(user_name)`.
   - Pass `user_name` through to strategy invocations.

**4. active_context.py:**
   - All queries on `ActiveContextItem` already filter by `user_id`. Now also filter by `user_name`.
   - `get_active_context(user_id, user_name)`: Add `ActiveContextItem.user_name == user_name` to WHERE clause.
   - `activate(user_id, memory_id, user_name)`: Set `user_name` on new ActiveContextItem.
   - `deactivate()`, `clear_active()`: Filter by `user_name`.

**5. communities.py:**
   - Community detection and rebuild: Filter member memories by `user_name`.
   - `rebuild_communities()`: Add `user_name` parameter. Query only memories for that user. Store `user_name` on created MemoryCommunity records.
   - Community queries: Add `MemoryCommunity.user_name == user_name` filter.

**6. entity_manager.py:**
   - Entity extraction: When extracting entities from a memory, associate with the memory's `user_name`.
   - Entity queries: Filter `ExtractedEntity.user_name == user_name`.
   - Set `user_name` on new ExtractedEntity records.

**7. cognitive/simulate.py, debate.py, evolve.py:**
   - These call `memory_manager.recall()` for evidence gathering. Pass `user_name` through.
   - When storing results (consensus memories, evolution insights), set `user_name`.

**8. similarity.py:**
   - TF-IDF index is built from all memories (this is fine per research -- IDF benefits from more data).
   - BUT: Add a note/comment that results must be post-filtered by user_name by callers.
   - If there's a `detect_conflict()` function that queries memories, add user_name filtering.
  </action>
  <verify>
    - `grep -rn "user_name" daem0nmcp/dreaming/` returns matches in all 3 files
    - `grep -rn "user_name" daem0nmcp/active_context.py` returns matches
    - `grep -rn "user_name" daem0nmcp/communities.py` returns matches
    - `grep -rn "user_name" daem0nmcp/entity_manager.py` returns matches
    - `grep -rn "user_name" daem0nmcp/cognitive/` returns matches in simulate, debate, evolve
    - `python -m pytest tests/test_memory.py -x -q` -- existing tests still pass
  </verify>
  <done>Every subsystem that queries memories filters by user_name. Dreaming runs per-user. Active context, communities, entities, and cognitive modules are all user-scoped.</done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive cross-user isolation tests</name>
  <files>
    tests/test_user_isolation.py
  </files>
  <action>
Create `tests/test_user_isolation.py` with comprehensive tests proving no cross-user memory leakage.

**Test structure:**
Use existing test fixtures from `conftest.py` (the `memory_manager` fixture provides a MemoryManager with a temp DB). For multi-user tests, create memories with different `user_name` values.

**Tests to write:**

1. **test_remember_stores_user_name:**
   - Call `remember(categories=["fact"], content="Alice likes cats", user_name="alice")`.
   - Verify the stored Memory has `user_name="alice"`.

2. **test_recall_isolated_by_user:**
   - Store 3 memories for user "alice" and 3 for user "bob".
   - Recall for "alice" returns only alice's memories (0 bob memories).
   - Recall for "bob" returns only bob's memories (0 alice memories).

3. **test_recall_default_user_backward_compat:**
   - Store memory without specifying user_name.
   - Recall without specifying user_name returns the memory (defaults to "default").

4. **test_forget_cannot_delete_other_users_memory:**
   - Store memory for "alice".
   - Attempt to delete it while current_user is "bob".
   - Verify memory still exists.

5. **test_active_context_isolated:**
   - Activate context item for "alice".
   - Query active context for "bob" returns empty.

6. **test_qdrant_search_isolated (if Qdrant available):**
   - Store 2 memories with embeddings for "alice", 2 for "bob".
   - Vector search for "alice" returns only alice's vectors.
   - Skip test if Qdrant not available.

7. **test_default_user_rename:**
   - Store 3 memories as user_name="default".
   - Rename "default" to "alice" (UPDATE memories SET user_name='alice' WHERE user_name='default').
   - Recall as "alice" returns all 3 memories.
   - Recall as "default" returns 0 memories.

8. **test_multiple_users_on_same_device:**
   - Store memories for "alice", "bob", and "charlie".
   - Each user's recall returns only their own memories.
   - Total memory count across all users matches sum of individual counts.

**Test helpers:**
- `async def _store_for_user(mm, user_name, content, categories=["fact"])` -- convenience wrapper.
- `async def _recall_for_user(mm, user_name, topic="*")` -- convenience wrapper.
  </action>
  <verify>
    - `python -m pytest tests/test_user_isolation.py -x -v` -- all 8+ tests pass
    - `python -m pytest tests/test_memory.py tests/test_daem0n_tools.py tests/test_user_isolation.py -x -q` -- full suite passes
  </verify>
  <done>Comprehensive test suite proves: recall isolation, forget isolation, active context isolation, default user backward compat, default-to-named-user rename, and multi-user device scenario all work correctly.</done>
</task>

</tasks>

<verification>
1. No un-scoped memory queries remain: `grep -rn "select(Memory)" daem0nmcp/ | grep -v "user_name" | grep -v "test_" | grep -v "__pycache__"` returns no results (or only migration/schema files)
2. Dreaming is per-user: `grep "user_name" daem0nmcp/dreaming/scheduler.py` returns match
3. All isolation tests pass: `python -m pytest tests/test_user_isolation.py -x -v`
4. Full test suite passes: `python -m pytest tests/test_memory.py tests/test_daem0n_tools.py tests/test_user_isolation.py -x -q`
</verification>

<success_criteria>
- Every file in daem0nmcp/ that queries Memory includes user_name filtering
- Dream scheduler iterates per-user, never crossing user boundaries
- Active context, communities, and entities are user-scoped
- Cognitive modules pass user_name through to recall() calls
- 8+ isolation tests pass proving no cross-user leakage
- All existing tests continue to pass (backward compat)
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-profiles-multi-user/02-03-SUMMARY.md`
</output>
