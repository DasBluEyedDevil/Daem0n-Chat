---
phase: 02-user-profiles-multi-user
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - daem0nmcp/models.py
  - daem0nmcp/migrations/schema.py
  - daem0nmcp/context_manager.py
  - daem0nmcp/memory.py
  - daem0nmcp/qdrant_store.py
autonomous: true

must_haves:
  truths:
    - "Every memory stored has a user_name field identifying who it belongs to"
    - "Recalling memories for user A never returns memories belonging to user B"
    - "Qdrant vector search respects user_name isolation"
    - "Existing single-user memories migrate to user_name='default' without data loss"
    - "UserContext tracks current_user for the active session"
  artifacts:
    - path: "daem0nmcp/models.py"
      provides: "Memory model with user_name column"
      contains: "user_name = Column"
    - path: "daem0nmcp/migrations/schema.py"
      provides: "Migration 18 adding user_name to memories and related tables"
      contains: "Add user_name column"
    - path: "daem0nmcp/context_manager.py"
      provides: "UserContext with current_user field"
      contains: "current_user"
    - path: "daem0nmcp/memory.py"
      provides: "user_name filtering on remember() and recall()"
      contains: "Memory.user_name"
    - path: "daem0nmcp/qdrant_store.py"
      provides: "user_name payload filter on search()"
      contains: "user_name"
  key_links:
    - from: "daem0nmcp/memory.py"
      to: "daem0nmcp/models.py"
      via: "Memory.user_name column used in WHERE clauses"
      pattern: "Memory\\.user_name"
    - from: "daem0nmcp/memory.py"
      to: "daem0nmcp/qdrant_store.py"
      via: "user_name passed in metadata and search filter"
      pattern: "user_name"
    - from: "daem0nmcp/context_manager.py"
      to: "daem0nmcp/memory.py"
      via: "current_user flows from UserContext to memory operations"
      pattern: "current_user"
---

<objective>
Add per-user memory isolation at the data layer. Every memory gets a `user_name` column, all core memory operations (remember, recall, search) filter by it, and Qdrant vector search respects user boundaries.

Purpose: This is the privacy foundation -- without user_name scoping on every query, multi-user memory isolation is impossible. Everything in Phase 2 builds on this.

Output: Memory model with user_name, migration 18, UserContext.current_user, user-scoped remember/recall/search
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-user-profiles-multi-user/02-RESEARCH.md
@.planning/phases/01-codebase-cleanup-categories/01-01-SUMMARY.md
@.planning/phases/01-codebase-cleanup-categories/01-02-SUMMARY.md

@daem0nmcp/models.py
@daem0nmcp/migrations/schema.py
@daem0nmcp/context_manager.py
@daem0nmcp/memory.py
@daem0nmcp/qdrant_store.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add user_name column to schema and UserContext</name>
  <files>
    daem0nmcp/models.py
    daem0nmcp/migrations/schema.py
    daem0nmcp/context_manager.py
  </files>
  <action>
1. **models.py -- Add user_name to Memory:**
   - Add `user_name = Column(String, nullable=False, default="default", index=True)` to the Memory class, positioned after the `categories` column.
   - Add `user_name` column to `ActiveContextItem` class (after `user_id`).
   - Add `user_name` column to `MemoryCommunity` class (after `user_id`).
   - Add `user_name` column to `ExtractedEntity` class (after `user_id`).
   - Do NOT add a 'profile' category to VALID_CATEGORIES. Per research Open Question 1, profile data uses existing categories (fact, preference) with `tags=["profile"]`.

2. **migrations/schema.py -- Add migration 18:**
   - Add migration tuple `(18, "Add user_name column for multi-user support", [...])` to the MIGRATIONS list.
   - SQL statements:
     ```sql
     ALTER TABLE memories ADD COLUMN user_name TEXT DEFAULT 'default';
     UPDATE memories SET user_name = 'default' WHERE user_name IS NULL;
     CREATE INDEX IF NOT EXISTS idx_memories_user_name ON memories(user_name);
     ALTER TABLE active_context ADD COLUMN user_name TEXT DEFAULT 'default';
     UPDATE active_context SET user_name = 'default' WHERE user_name IS NULL;
     ALTER TABLE memory_communities ADD COLUMN user_name TEXT DEFAULT 'default';
     UPDATE memory_communities SET user_name = 'default' WHERE user_name IS NULL;
     ALTER TABLE extracted_entities ADD COLUMN user_name TEXT DEFAULT 'default';
     UPDATE extracted_entities SET user_name = 'default' WHERE user_name IS NULL;
     ```

3. **context_manager.py -- Extend UserContext:**
   - Add `current_user: str = "default"` field to the UserContext dataclass.
   - Add `known_users: List[str] = field(default_factory=list)` field.
   - Import `List` from typing if not already imported (it is -- check).
  </action>
  <verify>
    - `python -c "from daem0nmcp.models import Memory; assert hasattr(Memory, 'user_name')"` succeeds
    - `python -c "from daem0nmcp.context_manager import UserContext; ctx = UserContext.__dataclass_fields__; assert 'current_user' in ctx and 'known_users' in ctx"` succeeds
    - Migration 18 exists in MIGRATIONS list: `python -c "from daem0nmcp.migrations.schema import MIGRATIONS; assert any(v == 18 for v, _, _ in MIGRATIONS)"`
  </verify>
  <done>Memory model has user_name column, migration 18 exists, UserContext has current_user and known_users fields</done>
</task>

<task type="auto">
  <name>Task 2: Add user_name filtering to memory operations and Qdrant</name>
  <files>
    daem0nmcp/memory.py
    daem0nmcp/qdrant_store.py
  </files>
  <action>
1. **memory.py -- Add user_name to remember():**
   - Add `user_name: Optional[str] = None` parameter to `remember()`.
   - When creating the Memory ORM object, set `user_name=user_name or "default"`.
   - When upserting to Qdrant, add `"user_name": user_name or "default"` to the metadata dict (all 3 upsert_memory call sites in the file).
   - When creating MemoryVersion records, no change needed (they reference memory_id, user is implicit).

2. **memory.py -- Add user_name to recall():**
   - Add `user_name: Optional[str] = None` parameter to `recall()`.
   - In the main query building, add `Memory.user_name == (user_name or "default")` to the WHERE clause alongside existing filters.
   - When calling Qdrant search, pass `user_name=user_name` to the search method.
   - In `_search_hybrid()` or wherever Qdrant search is called, pass user_name through.
   - For TF-IDF results: post-filter by user_name. After getting TF-IDF scored results (memory IDs), when loading from DB, include the user_name filter in the query. This is the simpler approach recommended by research (post-filter rather than per-user index).

3. **memory.py -- Add user_name to other query methods:**
   - `forget()` / `delete_memory()`: Add user_name filter to the delete query so one user cannot delete another user's memories.
   - `record_outcome()`: Add user_name check -- verify the memory belongs to the user before recording outcome.
   - `_build_search_query()` or equivalent: Ensure user_name filter is applied.

4. **qdrant_store.py -- Add user_name filtering:**
   - Add `user_name: Optional[str] = None` parameter to `search()` method.
   - When user_name is provided, add `FieldCondition(key="user_name", match=MatchValue(value=user_name))` to the filters list.
   - No changes needed to `upsert_memory()` -- user_name flows through the metadata dict from memory.py.
   - No changes needed to `delete_memory()` -- deletion is by memory_id which is already scoped.

5. **memory.py -- Update Qdrant metadata in all upsert call sites:**
   - There are 3 places in memory.py that call `self._qdrant.upsert_memory()`. Each one passes a `metadata` dict. Add `"user_name": user_name or "default"` (or the appropriate variable holding user_name) to each metadata dict.
  </action>
  <verify>
    - Run existing passing tests: `python -m pytest tests/test_memory.py -x -q` -- should still pass (default user_name="default" maintains backward compatibility)
    - Run new tool tests: `python -m pytest tests/test_daem0n_tools.py -x -q` -- should still pass
    - Verify Qdrant search accepts user_name: `python -c "from daem0nmcp.qdrant_store import QdrantVectorStore; import inspect; sig = inspect.signature(QdrantVectorStore.search); assert 'user_name' in sig.parameters"`
  </verify>
  <done>remember() and recall() accept and filter by user_name, Qdrant search filters by user_name payload, all Qdrant upserts include user_name in metadata, existing tests pass with default user_name</done>
</task>

</tasks>

<verification>
1. Memory model has `user_name` column: `grep -c "user_name = Column" daem0nmcp/models.py` returns >= 1
2. Migration 18 exists: `grep "Add user_name" daem0nmcp/migrations/schema.py` returns match
3. UserContext has current_user: `grep "current_user" daem0nmcp/context_manager.py` returns match
4. remember() has user_name param: `grep "user_name" daem0nmcp/memory.py | grep "def remember"` returns match
5. recall() has user_name param: similar grep check
6. Qdrant search has user_name filter: `grep "user_name" daem0nmcp/qdrant_store.py` returns match
7. All existing tests pass: `python -m pytest tests/test_memory.py tests/test_daem0n_tools.py -x -q`
</verification>

<success_criteria>
- user_name column exists on Memory, ActiveContextItem, MemoryCommunity, ExtractedEntity models
- Migration 18 adds user_name to all relevant tables with 'default' backfill
- UserContext.current_user tracks active user, UserContext.known_users tracks all users on device
- MemoryManager.remember() stores user_name on new memories
- MemoryManager.recall() filters results by user_name
- Qdrant search applies user_name payload filter
- All existing tests continue to pass (backward compatible via default="default")
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-profiles-multi-user/02-01-SUMMARY.md`
</output>
