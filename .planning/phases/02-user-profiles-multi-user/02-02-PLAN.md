---
phase: 02-user-profiles-multi-user
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - daem0nmcp/tools/daem0n_profile.py
  - daem0nmcp/tools/daem0n_briefing.py
  - daem0nmcp/tools/daem0n_remember.py
  - daem0nmcp/tools/daem0n_recall.py
  - daem0nmcp/tools/daem0n_forget.py
  - daem0nmcp/tools/daem0n_reflect.py
  - daem0nmcp/tools/daem0n_relate.py
  - daem0nmcp/tools/daem0n_status.py
  - tests/test_daem0n_tools.py
autonomous: true

must_haves:
  truths:
    - "Claude greets returning user by name on session start"
    - "If user corrects identity ('I'm not Susan'), Claude switches to the correct user"
    - "New user on existing device gets friendly onboarding (name question, 3 natural questions)"
    - "Claude offers to go by a different name per user"
    - "Profile data (name, core identity) is stored as permanent fact memories with profile tags"
    - "All 8 daem0n_* tools pass user_name through to memory operations"
  artifacts:
    - path: "daem0nmcp/tools/daem0n_profile.py"
      provides: "User switching, onboarding, profile get/set"
      contains: "switch_user"
    - path: "daem0nmcp/tools/daem0n_briefing.py"
      provides: "Identity verification on session start, multi-user awareness"
      contains: "current_user"
    - path: "tests/test_daem0n_tools.py"
      provides: "Tests for profile switching and multi-user briefing"
      contains: "test_profile"
  key_links:
    - from: "daem0nmcp/tools/daem0n_briefing.py"
      to: "daem0nmcp/context_manager.py"
      via: "Sets ctx.current_user based on known users"
      pattern: "ctx\\.current_user"
    - from: "daem0nmcp/tools/daem0n_profile.py"
      to: "daem0nmcp/memory.py"
      via: "Stores profile data as memories with tags=['profile']"
      pattern: "tags.*profile"
    - from: "daem0nmcp/tools/daem0n_remember.py"
      to: "daem0nmcp/memory.py"
      via: "Passes user_name from ctx.current_user to remember()"
      pattern: "user_name.*current_user"
---

<objective>
Implement the user-facing profile, identity, and tool integration for multi-user support. The briefing tool greets users by name and supports identity switching. The profile tool handles onboarding, user switching, and profile data storage. All 8 daem0n_* tools pipe user_name through to memory operations.

Purpose: Users experience Claude remembering them personally. Identity verification happens naturally through greeting ("Hi Susan!" -> "Actually I'm Steve"). Profile data flows as tagged memories, not a separate system.

Output: Working profile switching, identity-aware briefing, all tools user-scoped
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-user-profiles-multi-user/02-RESEARCH.md
@.planning/phases/02-user-profiles-multi-user/02-CONTEXT.md
@.planning/phases/02-user-profiles-multi-user/02-01-SUMMARY.md

@daem0nmcp/tools/daem0n_profile.py
@daem0nmcp/tools/daem0n_briefing.py
@daem0nmcp/tools/daem0n_remember.py
@daem0nmcp/context_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand daem0n_profile with user switching and onboarding</name>
  <files>
    daem0nmcp/tools/daem0n_profile.py
  </files>
  <action>
Rewrite `daem0n_profile.py` from its current stub (~77 lines) into the full user profile tool. Keep the `@mcp.tool` decorator and existing imports pattern.

**Actions to implement:**

1. **`action="get"` (existing, expand):**
   - Recall memories with `tags=["profile"]` for the current user (use `ctx.current_user` as user_name).
   - Separate into: identity (name, claude_name), facts, preferences.
   - Return structured profile dict: `{ type: "profile", user_name, greeting_name, claude_name, facts: [...], preferences: [...] }`.

2. **`action="switch_user"` (new):**
   - Requires `user_name` parameter.
   - Query DB for any memories with `Memory.user_name == user_name` to check if user exists.
   - If user exists (returning user): Set `ctx.current_user = user_name`, load their profile, return `{ type: "user_switched", user_name, profile, greeting: "Welcome back, {name}!" }`.
   - If user is new: Set `ctx.current_user = user_name`, return `{ type: "new_user", user_name, onboarding_guidance: "..." }`.
   - The onboarding guidance should instruct Claude to: (a) introduce itself warmly, (b) offer to go by a different name, (c) ask for the user's name, (d) weave in 2-3 natural getting-to-know-you questions (not an interview). Tone: playful and casual per locked decision.
   - Add user_name to `ctx.known_users` if not already present.

3. **`action="set_name"` (new):**
   - Requires `name` parameter.
   - Store as a permanent fact memory: `categories=["fact"], tags=["profile", "identity", "name"], content="User's name is {name}", is_permanent=True`.
   - If current user was "default", UPDATE all memories with `user_name="default"` to `user_name=name`. This handles the bootstrap case where we learn the user's real name.
   - Return confirmation.

4. **`action="set_claude_name"` (new):**
   - Requires `name` parameter.
   - Store as a permanent fact memory: `categories=["fact"], tags=["profile", "identity", "claude_name"], content="User calls Claude '{name}'"`.
   - Return confirmation.

5. **`action="list_users"` (new):**
   - Query distinct user_name values from memories table.
   - Return list of known users on this device with memory counts.

**Important implementation notes:**
- Use `ctx.current_user` (from UserContext, set by 02-01) as the user_name for memory operations.
- Profile data is stored as memories with `tags=["profile"]` per locked decision (not a separate table).
- Core identity facts (name) are permanent. Preferences can decay.
- When switching users, always update `ctx.current_user` so subsequent tool calls use the right user.
  </action>
  <verify>
    - `python -c "from daem0nmcp.tools.daem0n_profile import daem0n_profile; import inspect; sig = inspect.signature(daem0n_profile); assert 'action' in sig.parameters"` succeeds
    - `grep -c "switch_user\|set_name\|set_claude_name\|list_users" daem0nmcp/tools/daem0n_profile.py` returns >= 4
  </verify>
  <done>daem0n_profile supports get, switch_user, set_name, set_claude_name, list_users actions. Profile data stored as tagged memories. User switching updates ctx.current_user.</done>
</task>

<task type="auto">
  <name>Task 2: Multi-user briefing + user_name piping in all tools + tests</name>
  <files>
    daem0nmcp/tools/daem0n_briefing.py
    daem0nmcp/tools/daem0n_remember.py
    daem0nmcp/tools/daem0n_recall.py
    daem0nmcp/tools/daem0n_forget.py
    daem0nmcp/tools/daem0n_reflect.py
    daem0nmcp/tools/daem0n_relate.py
    daem0nmcp/tools/daem0n_status.py
    tests/test_daem0n_tools.py
  </files>
  <action>
**Part A: Rewrite daem0n_briefing.py for multi-user:**

1. **First session on new device (total_memories == 0):**
   - Return `is_new_device: True` and `is_first_session: True`.
   - Guidance: "Brand new device. Introduce yourself warmly. Ask the user's name. Offer to go by a different name. Ask 2-3 natural getting-to-know-you questions."

2. **Returning device with known users:**
   - Query distinct `user_name` from memories to find known users (exclude "default" if a real named user exists).
   - Set `ctx.current_user` to the most recently active user (user with most recent `Memory.created_at`).
   - Load that user's profile: recall memories with `tags=["profile"]` and `user_name=ctx.current_user`.
   - Extract greeting_name from profile facts (the memory tagged `["profile", "identity", "name"]`).
   - Extract claude_name from profile (memory tagged `["profile", "identity", "claude_name"]`), default to "Claude".
   - Return briefing with: `current_user`, `greeting_name`, `claude_name`, `identity_hint` ("Greet user as {name}. If they correct you, use daem0n_profile(action='switch_user') to switch."), plus existing fields (user_summary, unresolved_threads, recent_topics, emotional_context, active_routines).
   - ALL memory queries in briefing must filter by `user_name=ctx.current_user`.

3. **First session for default user (memories exist but user_name is all "default"):**
   - Return `is_first_session: True` (no named user yet).
   - Guidance should prompt Claude to learn the user's name.

**Part B: Pipe user_name through all 8 daem0n_* tools:**

Every tool that calls `ctx.memory_manager.remember()`, `ctx.memory_manager.recall()`, or queries memories directly must pass `user_name=ctx.current_user`.

Specific changes:
- **daem0n_remember.py:** Pass `user_name=ctx.current_user` to `ctx.memory_manager.remember()`.
- **daem0n_recall.py:** Pass `user_name=ctx.current_user` to `ctx.memory_manager.recall()`.
- **daem0n_forget.py:** When deleting, verify the memory belongs to `ctx.current_user` before deletion. Add `Memory.user_name == ctx.current_user` to the delete query.
- **daem0n_reflect.py:** Pass `user_name=ctx.current_user` to outcome recording.
- **daem0n_relate.py:** Pass `user_name=ctx.current_user` to graph operations.
- **daem0n_status.py:** Filter memory count/breakdown by `user_name=ctx.current_user` in the stats query.

**Part C: Update tests:**

Add to `tests/test_daem0n_tools.py`:
1. `test_profile_get` -- get profile for default user returns empty facts.
2. `test_profile_switch_user_new` -- switch to new user returns onboarding guidance.
3. `test_profile_set_name` -- set name stores permanent fact with profile tag.
4. `test_briefing_first_session` -- first session returns is_first_session=True (existing test, verify it still passes).
5. `test_briefing_returning_user_greets_by_name` -- after storing a name fact, briefing returns greeting_name.
6. `test_remember_scoped_to_user` -- remember as user A, recall as user B returns nothing.
  </action>
  <verify>
    - `python -m pytest tests/test_daem0n_tools.py -x -q` -- all tests pass
    - `grep "current_user" daem0nmcp/tools/daem0n_remember.py` returns match
    - `grep "current_user" daem0nmcp/tools/daem0n_briefing.py` returns match
    - `grep "user_name" daem0nmcp/tools/daem0n_forget.py` returns match
  </verify>
  <done>Briefing greets by name, supports identity hint for switching. All 8 tools pipe user_name through to memory operations. Tests verify profile CRUD, user switching, and cross-user isolation.</done>
</task>

</tasks>

<verification>
1. Profile switching works: store name as user A, switch to user B, verify A's profile not visible
2. Briefing shows greeting_name: store profile name, call briefing, verify greeting_name matches
3. All tools pass user_name: grep each tool file for `current_user` or `user_name`
4. Tests pass: `python -m pytest tests/test_daem0n_tools.py -x -q`
5. Existing tests pass: `python -m pytest tests/test_memory.py -x -q`
</verification>

<success_criteria>
- daem0n_profile supports 5 actions: get, switch_user, set_name, set_claude_name, list_users
- daem0n_briefing greets returning user by name, provides identity_hint for switching
- All 8 daem0n_* tools pass user_name to memory operations via ctx.current_user
- Profile data stored as memories with tags=["profile"] (not a separate table)
- Core identity (name) is permanent, preferences can decay
- New tests verify profile, switching, and isolation
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-profiles-multi-user/02-02-SUMMARY.md`
</output>
