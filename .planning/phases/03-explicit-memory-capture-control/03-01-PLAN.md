---
phase: 03-explicit-memory-capture-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - daem0nmcp/tools/daem0n_forget.py
  - tests/test_daem0n_tools.py
autonomous: true

must_haves:
  truths:
    - "User can say 'forget what I told you about my sister' and matching memories are found via semantic search"
    - "User can confirm which matched memories to delete, and they are permanently removed from SQLite, Qdrant, and TF-IDF"
    - "Deleted memories do not reappear in recall results (recall cache cleared after deletion)"
    - "Batch deletion removes multiple memories in a single call"
  artifacts:
    - path: "daem0nmcp/tools/daem0n_forget.py"
      provides: "Enhanced forget with query search, batch delete, cache fix"
      exports: ["daem0n_forget"]
    - path: "tests/test_daem0n_tools.py"
      provides: "Tests for semantic forget, batch delete, cache invalidation"
      contains: "TestDaem0nForget"
  key_links:
    - from: "daem0nmcp/tools/daem0n_forget.py"
      to: "daem0nmcp/memory.py"
      via: "ctx.memory_manager.recall() for semantic search"
      pattern: "memory_manager\\.recall"
    - from: "daem0nmcp/tools/daem0n_forget.py"
      to: "daem0nmcp/cache.py"
      via: "get_recall_cache().clear() after deletion"
      pattern: "get_recall_cache.*clear"
---

<objective>
Enhance `daem0n_forget` to support content-based semantic search for deletion (find-then-delete pattern) and batch deletion, plus fix the recall cache invalidation bug.

Purpose: Users describe what they want forgotten in natural language ("forget what I said about my sister"), not by memory ID. The tool must search semantically, return candidates, then delete confirmed matches. The cache bug means deleted memories could reappear for 5 seconds -- this must be fixed.

Output: Enhanced `daem0n_forget` tool with query/confirm_ids parameters and comprehensive tests.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-explicit-memory-capture-control/03-RESEARCH.md
@daem0nmcp/tools/daem0n_forget.py
@daem0nmcp/tools/daem0n_recall.py
@daem0nmcp/cache.py
@tests/test_daem0n_tools.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance daem0n_forget with query search, batch delete, and cache fix</name>
  <files>daem0nmcp/tools/daem0n_forget.py</files>
  <action>
Rewrite `daem0n_forget` to support three modes of operation while preserving the existing single-ID delete path.

**New signature:**
```python
async def daem0n_forget(
    memory_id: Optional[int] = None,       # Delete a single memory by ID (existing behavior)
    query: Optional[str] = None,           # Search for memories to forget (returns candidates)
    confirm_ids: Optional[List[int]] = None,  # Batch delete after search confirmation
    user_id: Optional[str] = None,
) -> Dict[str, Any]:
```

**Mode 1: Single ID delete (existing, enhanced with cache fix)**
- When `memory_id` is provided (and no query/confirm_ids): same behavior as current code
- Add `from ..cache import get_recall_cache` import
- After the existing deletion steps (SQLite, Qdrant, TF-IDF, graph cache), add: `get_recall_cache().clear()`
- This fixes the bug where deleted memories reappear in recall for up to 5 seconds

**Mode 2: Semantic search (query mode)**
- When `query` is provided (and no memory_id/confirm_ids): search for matching memories
- Use `ctx.memory_manager.recall(topic=query, limit=10, user_id=ctx.user_id, user_name=ctx.current_user)`
- Return result with `type: "forget_candidates"`, the query, and a list of candidates (id, content, categories, created_at)
- Include a message like: `"Found N memories matching 'query'. To delete, call daem0n_forget with confirm_ids=[id1, id2, ...]"`
- Do NOT delete anything in this mode -- search only

**Mode 3: Batch delete (confirm_ids mode)**
- When `confirm_ids` is provided (List[int]): delete all specified memories
- Validate that exactly one mode is used (return error if memory_id AND confirm_ids both provided, or if none provided)
- For each ID in confirm_ids:
  - Verify memory exists and belongs to ctx.current_user (same check as single delete)
  - Delete from SQLite via `delete(Memory).where(Memory.id == mid, Memory.user_name == ctx.current_user)`
  - Track deleted_ids and failed_ids (failed = not found or wrong user)
- After the loop, commit once (single transaction for all deletes)
- Clean up all storage layers for deleted IDs:
  - Qdrant: `ctx.memory_manager._qdrant.delete_memory(mid)` for each (wrapped in try/except)
  - TF-IDF: `ctx.memory_manager._index.remove_document(mid)` for each
- Invalidate graph cache: `ctx.memory_manager.invalidate_graph_cache()`
- Clear recall cache: `get_recall_cache().clear()`
- Return `type: "batch_deleted"`, deleted_ids, failed_ids, counts

**Validation:**
- If none of memory_id, query, confirm_ids provided: return error with usage hint
- If more than one mode provided (e.g., memory_id AND query): return error explaining only one mode at a time
- Empty confirm_ids list: return error

**Update tool docstring** to explain the three modes clearly:
```
Permanently delete memories. Three modes:
- By ID: pass memory_id to delete one specific memory.
- By search: pass query to find memories matching a description. Returns candidates -- does NOT delete.
- By batch: pass confirm_ids (list of IDs) to delete multiple memories at once (typically after a search).
```
  </action>
  <verify>
Run `python -m pytest tests/test_daem0n_tools.py::TestDaem0nForget -v` -- existing tests must still pass (they use memory_id= which is Mode 1).
Import check: `python -c "from daem0nmcp.tools.daem0n_forget import daem0n_forget; print('OK')"` should succeed.
  </verify>
  <done>
daem0n_forget supports all three modes: single ID delete (with cache fix), semantic query search returning candidates, and batch delete with confirm_ids. Existing single-ID tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests for semantic forget, batch delete, and cache invalidation</name>
  <files>tests/test_daem0n_tools.py</files>
  <action>
Add new tests to the existing `TestDaem0nForget` class in `tests/test_daem0n_tools.py`. Follow the exact mocking pattern used by the existing tests (patch `get_user_context`, mock ctx with db_manager session, etc.).

**New tests to add:**

1. `test_forget_query_returns_candidates` -- When `query="sister"` is passed (no memory_id):
   - Mock `ctx.memory_manager.recall` to return 2 matching memories
   - Assert result has `type: "forget_candidates"`, assert candidates list has 2 items with id/content/categories
   - Assert no deletion calls were made (session.execute should NOT receive a `delete()` statement)

2. `test_forget_confirm_ids_batch_delete` -- When `confirm_ids=[1, 2]` is passed:
   - Mock session.execute for select queries to return mock Memory objects for both IDs (matching ctx.current_user)
   - Mock session.execute for delete queries
   - Mock session.commit
   - Mock _qdrant and _index
   - Assert result has `type: "batch_deleted"`, `deleted_ids: [1, 2]`, `failed_ids: []`
   - Assert `ctx.memory_manager.invalidate_graph_cache()` was called

3. `test_forget_confirm_ids_partial_failure` -- When `confirm_ids=[1, 999]`:
   - Mock: ID 1 exists for user, ID 999 returns None (not found)
   - Assert result has `deleted_ids: [1]` and `failed_ids: [999]`

4. `test_forget_cache_cleared_on_delete` -- Single ID delete clears recall cache:
   - Patch `daem0nmcp.tools.daem0n_forget.get_recall_cache` to return a mock cache
   - Perform a single-ID delete (same as existing test_forget_existing_memory setup)
   - Assert `mock_cache.clear()` was called

5. `test_forget_no_params_returns_error` -- Call with no params:
   - Assert result contains "error"

6. `test_forget_conflicting_params_returns_error` -- Call with both memory_id=1 AND query="test":
   - Assert result contains "error"

**Important mocking detail for batch tests:** The session.execute mock needs to handle multiple calls (select for each ID, delete for each ID). Use `side_effect` with a list of mock results, or use a counter-based side_effect function similar to the briefing tests.

**Import note:** Add `from daem0nmcp.cache import get_recall_cache` to the test file if needed for the cache test, or patch the import path in the forget module.
  </action>
  <verify>
Run `python -m pytest tests/test_daem0n_tools.py::TestDaem0nForget -v` -- all tests (old + new) pass.
Run `python -m pytest tests/test_daem0n_tools.py -v` -- full test file passes (no regressions in other test classes).
  </verify>
  <done>
6 new tests pass covering: semantic query returns candidates without deleting, batch delete with confirm_ids, partial failure handling, recall cache invalidation on delete, no-params error, conflicting-params error.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_daem0n_tools.py::TestDaem0nForget -v` -- all forget tests pass (2 existing + 6 new)
2. `python -m pytest tests/test_daem0n_tools.py -v` -- full test suite passes (no regressions)
3. `python -c "from daem0nmcp.tools.daem0n_forget import daem0n_forget"` -- import succeeds
</verification>

<success_criteria>
- daem0n_forget supports query-based semantic search returning candidates (no deletion)
- daem0n_forget supports batch deletion via confirm_ids
- Recall cache is cleared after any deletion (bug fix)
- All 8+ forget tests pass
- No regressions in other tool tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-explicit-memory-capture-control/03-01-SUMMARY.md`
</output>
