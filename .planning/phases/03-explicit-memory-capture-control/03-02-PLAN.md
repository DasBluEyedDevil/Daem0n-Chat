---
phase: 03-explicit-memory-capture-control
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - daem0nmcp/tools/daem0n_profile.py
  - daem0nmcp/tools/daem0n_remember.py
  - tests/test_daem0n_tools.py
autonomous: true

must_haves:
  truths:
    - "User can ask 'what do you know about me?' and receives a structured summary organized by category with counts"
    - "User can say 'remember that my sister is Sarah' and the fact is stored as permanent with explicit tag"
    - "Introspection shows all memories grouped by the 10 categories (fact, preference, interest, goal, concern, event, relationship, emotion, routine, context)"
    - "Explicit memories are marked permanent (is_permanent=True) and tagged with 'explicit'"
  artifacts:
    - path: "daem0nmcp/tools/daem0n_profile.py"
      provides: "introspect action for comprehensive memory audit"
      contains: "introspect"
    - path: "daem0nmcp/tools/daem0n_remember.py"
      provides: "Enhanced tool description guiding explicit remember with permanent + explicit tag"
      exports: ["daem0n_remember"]
    - path: "tests/test_daem0n_tools.py"
      provides: "Tests for introspection format and explicit remember permanence"
      contains: "test_introspect"
  key_links:
    - from: "daem0nmcp/tools/daem0n_profile.py"
      to: "daem0nmcp/models.py"
      via: "SQLAlchemy query on Memory table grouped by categories"
      pattern: "select.*Memory.*where.*user_name"
    - from: "daem0nmcp/tools/daem0n_remember.py"
      to: "daem0nmcp/memory.py"
      via: "memory_manager.remember() with is_permanent and explicit tag"
      pattern: "memory_manager\\.remember"
---

<objective>
Add memory introspection ("what do you know about me?") as a new `introspect` action on `daem0n_profile`, and enhance `daem0n_remember` with explicit memory tagging and forced permanence for user-requested memories.

Purpose: Users need transparency into what Claude remembers (CTRL-01) and explicit control to store specific facts permanently (CMEM-03). Introspection goes on `daem0n_profile` to keep the tool count at 8. Explicit remember is mostly a tool description + is_permanent enhancement.

Output: Enhanced `daem0n_profile` with introspect action, enhanced `daem0n_remember` with explicit/permanent support, and comprehensive tests.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-explicit-memory-capture-control/03-RESEARCH.md
@daem0nmcp/tools/daem0n_profile.py
@daem0nmcp/tools/daem0n_remember.py
@daem0nmcp/models.py
@tests/test_daem0n_tools.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add introspect action to daem0n_profile and enhance daem0n_remember</name>
  <files>daem0nmcp/tools/daem0n_profile.py, daem0nmcp/tools/daem0n_remember.py</files>
  <action>
**Part A: Add `introspect` action to daem0n_profile**

1. Add `"introspect"` to `VALID_ACTIONS` set (becomes 6 actions).

2. Update the tool docstring to include the new action:
   ```
   - 'introspect': Show everything Claude knows about the current user, organized by category.
   ```

3. Add the introspect handler block (after the `list_users` elif, before the final return). Implementation:

   ```python
   elif action == "introspect":
       current = ctx.current_user

       # Query ALL non-archived memories for this user
       async with ctx.db_manager.get_session() as session:
           from sqlalchemy import or_
           result = await session.execute(
               select(Memory).where(
                   Memory.user_name == current,
                   or_(Memory.archived == False, Memory.archived.is_(None)),
               ).order_by(Memory.created_at.desc())
           )
           memories = result.scalars().all()

       # Group by category (memories can appear in multiple groups)
       by_category = {}
       permanent_count = 0
       for mem in memories:
           cats = mem.categories or []
           if mem.is_permanent:
               permanent_count += 1
           for cat in cats:
               if cat not in by_category:
                   by_category[cat] = {"count": 0, "memories": []}
               by_category[cat]["count"] += 1
               by_category[cat]["memories"].append({
                   "id": mem.id,
                   "content": mem.content[:150],  # Truncate long content
                   "tags": mem.tags or [],
                   "created_at": mem.created_at.isoformat() if mem.created_at else None,
                   "is_permanent": mem.is_permanent,
               })

       # Sort categories alphabetically for consistent output
       sorted_categories = dict(sorted(by_category.items()))

       return {
           "type": "introspection",
           "user_name": current,
           "total_memories": len(memories),
           "by_category": sorted_categories,
           "permanent_count": permanent_count,
           "total_categories_used": len(by_category),
           "note": "Individual category counts may exceed total_memories because memories can belong to multiple categories.",
       }
   ```

   Important: Import `or_` from sqlalchemy at the top of the file (add to existing `from sqlalchemy import select, func, update, distinct` line -- append `or_`).

**Part B: Enhance daem0n_remember for explicit memory capture**

1. Add `is_permanent: Optional[bool] = None` parameter to the `daem0n_remember` function signature (after `tags`, before `user_id`).

2. Update the tool docstring to guide Claude on explicit remember usage:
   ```
   Store a memory about the user. Categories: fact, preference, interest,
   goal, concern, event, relationship, emotion, routine, context.
   Supports multiple categories per memory.

   For explicit user requests ("remember that..."):
   - Set is_permanent=True (user explicitly asked to remember, so it should not decay)
   - Include "explicit" in tags to mark it as user-requested
   - Pick the most appropriate category from the content
   ```

3. When `is_permanent=True` is passed, after the `ctx.memory_manager.remember()` call, force permanence on the created memory:
   ```python
   if is_permanent and "id" in result:
       async with ctx.db_manager.get_session() as session:
           from sqlalchemy import update as sql_update
           await session.execute(
               sql_update(Memory).where(Memory.id == result["id"]).values(
                   is_permanent=True,
               )
           )
           await session.commit()
       result["is_permanent"] = True
   ```

   Import Memory model: add to the existing try/except import block -- `from ..models import VALID_CATEGORIES, Memory` (and same for the except ImportError branch).

   Note: We force permanence AFTER remember() because remember() may set is_permanent based on category rules, but the user's explicit request should override. This guarantees permanence regardless of category.
  </action>
  <verify>
Import check: `python -c "from daem0nmcp.tools.daem0n_profile import daem0n_profile; print('OK')"` succeeds.
Import check: `python -c "from daem0nmcp.tools.daem0n_remember import daem0n_remember; print('OK')"` succeeds.
Run existing tests: `python -m pytest tests/test_daem0n_tools.py::TestDaem0nProfile tests/test_daem0n_tools.py::TestDaem0nRemember -v` -- all existing tests still pass.
  </verify>
  <done>
daem0n_profile has 6 actions including introspect (returns all memories grouped by category with counts). daem0n_remember accepts is_permanent flag and documents explicit tag convention. Existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests for introspection and explicit remember</name>
  <files>tests/test_daem0n_tools.py</files>
  <action>
Add new tests to the existing test file. Follow the exact mocking patterns used by existing tests.

**Introspection tests (add to TestDaem0nProfile class):**

1. `test_profile_introspect_returns_grouped_memories` -- Main introspection test:
   - Mock ctx with current_user="Alice"
   - Mock session.execute to return a scalars() result with 3 mock Memory objects:
     - Memory 1: id=1, content="Sister is Sarah", categories=["fact", "relationship"], tags=[], is_permanent=True, archived=False, created_at=datetime(2026, 2, 7, tzinfo=timezone.utc)
     - Memory 2: id=2, content="Likes hiking", categories=["preference"], tags=[], is_permanent=False, archived=False, created_at=datetime(2026, 2, 6, tzinfo=timezone.utc)
     - Memory 3: id=3, content="Works at Google", categories=["fact"], tags=["profile"], is_permanent=True, archived=False, created_at=datetime(2026, 2, 5, tzinfo=timezone.utc)
   - Assert result["type"] == "introspection"
   - Assert result["user_name"] == "Alice"
   - Assert result["total_memories"] == 3
   - Assert "fact" in result["by_category"] and result["by_category"]["fact"]["count"] == 2
   - Assert "relationship" in result["by_category"] and result["by_category"]["relationship"]["count"] == 1
   - Assert "preference" in result["by_category"] and result["by_category"]["preference"]["count"] == 1
   - Assert result["permanent_count"] == 2
   - Assert result["total_categories_used"] == 3

2. `test_profile_introspect_empty` -- No memories:
   - Mock session to return empty scalars result
   - Assert result["total_memories"] == 0
   - Assert result["by_category"] == {}
   - Assert result["permanent_count"] == 0

3. `test_profile_introspect_content_truncated` -- Long content is truncated:
   - Mock session with one Memory object whose content is "A" * 200 (200 chars)
   - Assert the content in result["by_category"][...]["memories"][0]["content"] has length <= 150

**Explicit remember tests (add to TestDaem0nRemember class):**

4. `test_remember_explicit_sets_permanent` -- When is_permanent=True:
   - Mock ctx with memory_manager.remember returning {"id": 5, "categories": ["fact"], "content": "Sister is Sarah"}
   - Mock db_manager session for the update query (session.execute + session.commit)
   - Call daem0n_remember with content="Sister is Sarah", categories="fact", tags=["explicit"], is_permanent=True
   - Assert result["is_permanent"] is True
   - Assert session.execute was called (the UPDATE statement for is_permanent)

5. `test_remember_without_permanent_skips_update` -- When is_permanent is not passed:
   - Standard mock setup
   - Call daem0n_remember without is_permanent
   - Assert result does NOT have "is_permanent" key set to True by the tool (it may come from remember() result)
   - The db session for update should NOT have been used

**Important mock detail for introspect:** The session query returns `result.scalars().all()` which returns a list of Memory model instances. Create mock Memory objects with the required attributes (id, content, categories, tags, is_permanent, archived, created_at). Use `MagicMock(spec=Memory)` and set attributes directly.
  </action>
  <verify>
Run `python -m pytest tests/test_daem0n_tools.py::TestDaem0nProfile -v` -- all profile tests pass (7 existing + 3 new).
Run `python -m pytest tests/test_daem0n_tools.py::TestDaem0nRemember -v` -- all remember tests pass (4 existing + 2 new).
Run `python -m pytest tests/test_daem0n_tools.py -v` -- full test file passes.
  </verify>
  <done>
5 new tests pass covering: introspection with grouped memories and correct counts, empty introspection, content truncation, explicit remember forcing permanence, and non-explicit remember skipping the update.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_daem0n_tools.py -v` -- all tests pass (existing + new, 0 failures)
2. `python -c "from daem0nmcp.tools.daem0n_profile import VALID_ACTIONS; assert 'introspect' in VALID_ACTIONS"` -- introspect action registered
3. Verify introspection returns category-grouped format with counts
4. Verify explicit remember stores with is_permanent=True
</verification>

<success_criteria>
- daem0n_profile has 6 actions including introspect
- Introspection returns all memories grouped by 10 categories with counts, permanent_count, and truncated content
- daem0n_remember accepts is_permanent flag and forces permanence when True
- Tool description guides Claude to use explicit tag and is_permanent=True for user-requested memories
- All tests pass (existing + 5 new)
- No regressions in other tool tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-explicit-memory-capture-control/03-02-SUMMARY.md`
</output>
