---
phase: 07-knowledge-graph-adaptation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - daem0nmcp/models.py
  - daem0nmcp/migrations/schema.py
  - daem0nmcp/entity_extractor.py
  - daem0nmcp/graph/entity_resolver.py
  - daem0nmcp/entity_manager.py
autonomous: true

must_haves:
  truths:
    - "Personal entities (person, pet, place, organization, event) can be extracted from conversational text"
    - "Entity aliases map multiple references to the same canonical entity"
    - "Entity-to-entity relationships create direct edges between entities"
    - "Existing code-entity data coexists with new personal entity types"
  artifacts:
    - path: "daem0nmcp/models.py"
      provides: "EntityAlias and EntityRelationship models, personal entity/relationship type constants"
      contains: "PERSONAL_ENTITY_TYPES"
    - path: "daem0nmcp/migrations/schema.py"
      provides: "Migration 19 creating entity_aliases and entity_relationships tables"
      contains: "entity_aliases"
    - path: "daem0nmcp/entity_extractor.py"
      provides: "Personal entity extraction patterns replacing code-specific patterns"
      contains: "PERSONAL_PATTERNS"
    - path: "daem0nmcp/graph/entity_resolver.py"
      provides: "Alias-aware resolution that checks entity_aliases before creating new entities"
      contains: "alias"
    - path: "daem0nmcp/entity_manager.py"
      provides: "Personal entity processing with alias creation and entity-entity relationship storage"
      contains: "EntityRelationship"
  key_links:
    - from: "daem0nmcp/entity_extractor.py"
      to: "daem0nmcp/entity_manager.py"
      via: "EntityExtractor used in process_memory"
      pattern: "self\\.extractor\\.extract"
    - from: "daem0nmcp/graph/entity_resolver.py"
      to: "daem0nmcp/models.py"
      via: "Resolver queries EntityAlias table"
      pattern: "EntityAlias"
    - from: "daem0nmcp/entity_manager.py"
      to: "daem0nmcp/models.py"
      via: "Manager creates EntityRelationship rows"
      pattern: "EntityRelationship"
---

<objective>
Establish the data foundation for personal knowledge graph: new models, migration, personal entity extraction patterns, and alias-aware entity resolution.

Purpose: Phase 7 transforms the code-focused knowledge graph into a personal relationship graph. This plan creates the schema, extraction, and resolution layers that Plan 07-02 will build multi-hop queries on top of.

Output: EntityAlias and EntityRelationship models in DB, personal entity extraction replacing code patterns, alias-aware resolver.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-knowledge-graph-adaptation/07-RESEARCH.md
@daem0nmcp/models.py
@daem0nmcp/entity_extractor.py
@daem0nmcp/graph/entity_resolver.py
@daem0nmcp/entity_manager.py
@daem0nmcp/migrations/schema.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add models, constants, and migration for personal knowledge graph</name>
  <files>daem0nmcp/models.py, daem0nmcp/migrations/schema.py</files>
  <action>
In daem0nmcp/models.py:

1. Add personal entity type and relationship type constants AFTER the existing category constants (around line 36):

```python
# Personal entity types for knowledge graph (Phase 7)
PERSONAL_ENTITY_TYPES = frozenset({
    'person',        # People in user's life
    'pet',           # Pets (name, type, breed)
    'place',         # Locations (home, work, cities)
    'organization',  # Companies, schools, groups
    'event',         # Named events (birthday, wedding, interview)
})

# Relationship types between entities (entity-to-entity edges)
ENTITY_RELATIONSHIP_TYPES = frozenset({
    'knows',         # Person <-> Person general
    'sibling_of',    # Person <-> Person
    'parent_of',     # Person <-> Person
    'child_of',      # Person <-> Person
    'partner_of',    # Person <-> Person (spouse, dating)
    'friend_of',     # Person <-> Person
    'coworker_of',   # Person <-> Person
    'owns',          # Person -> Pet
    'lives_in',      # Person -> Place
    'works_at',      # Person -> Organization
    'attends',       # Person -> Organization (school)
    'member_of',     # Person -> Organization
    'located_in',    # Place/Org -> Place (nesting)
    'related_to',    # Generic fallback
})
```

2. Add EntityAlias model AFTER MemoryEntityRef (around line 535):

```python
class EntityAlias(Base):
    """Maps alternative references to canonical entities.

    Examples:
    - entity_id=42 (Sarah), alias="my sister", alias_type="relationship"
    - entity_id=42 (Sarah), alias="sis", alias_type="nickname"
    """
    __tablename__ = "entity_aliases"

    id = Column(Integer, primary_key=True, index=True)
    entity_id = Column(Integer, ForeignKey("extracted_entities.id", ondelete="CASCADE"), nullable=False, index=True)
    alias = Column(String, nullable=False, index=True)
    alias_type = Column(String, nullable=False)  # relationship, nickname, full_name
    user_name = Column(String, nullable=False, default="default", index=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))

    entity = orm_relationship("ExtractedEntity", backref="aliases")
```

3. Add EntityRelationship model AFTER EntityAlias:

```python
class EntityRelationship(Base):
    """Direct relationships between entities (entity-to-entity edges).

    Unlike MemoryRelationship (memory -> memory edges),
    this tracks entity -> entity edges:
    - Sarah -> owns -> Max (dog)
    - Sarah -> lives_in -> Portland
    """
    __tablename__ = "entity_relationships"

    id = Column(Integer, primary_key=True, index=True)
    source_entity_id = Column(Integer, ForeignKey("extracted_entities.id", ondelete="CASCADE"), nullable=False, index=True)
    target_entity_id = Column(Integer, ForeignKey("extracted_entities.id", ondelete="CASCADE"), nullable=False, index=True)
    relationship = Column(String, nullable=False, index=True)
    description = Column(Text, nullable=True)
    confidence = Column(Float, default=1.0)
    source_memory_id = Column(Integer, ForeignKey("memories.id", ondelete="SET NULL"), nullable=True)
    user_name = Column(String, nullable=False, default="default", index=True)
    created_at = Column(DateTime, default=lambda: datetime.now(timezone.utc))

    source_entity = orm_relationship("ExtractedEntity", foreign_keys=[source_entity_id], backref="outgoing_entity_relationships")
    target_entity = orm_relationship("ExtractedEntity", foreign_keys=[target_entity_id], backref="incoming_entity_relationships")
    source_memory = orm_relationship("Memory", backref="entity_relationship_sources")
```

In daem0nmcp/migrations/schema.py:

4. Add migration 19 to the MIGRATIONS list:

```python
(19, "Add entity_aliases and entity_relationships tables for personal knowledge graph", [
    """
    CREATE TABLE IF NOT EXISTS entity_aliases (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        entity_id INTEGER NOT NULL,
        alias TEXT NOT NULL,
        alias_type TEXT NOT NULL,
        user_name TEXT NOT NULL DEFAULT 'default',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (entity_id) REFERENCES extracted_entities(id) ON DELETE CASCADE
    );
    """,
    "CREATE INDEX IF NOT EXISTS idx_entity_aliases_entity ON entity_aliases(entity_id);",
    "CREATE INDEX IF NOT EXISTS idx_entity_aliases_alias ON entity_aliases(alias);",
    "CREATE INDEX IF NOT EXISTS idx_entity_aliases_user ON entity_aliases(user_name);",
    """
    CREATE TABLE IF NOT EXISTS entity_relationships (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        source_entity_id INTEGER NOT NULL,
        target_entity_id INTEGER NOT NULL,
        relationship TEXT NOT NULL,
        description TEXT,
        confidence REAL DEFAULT 1.0,
        source_memory_id INTEGER,
        user_name TEXT NOT NULL DEFAULT 'default',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (source_entity_id) REFERENCES extracted_entities(id) ON DELETE CASCADE,
        FOREIGN KEY (target_entity_id) REFERENCES extracted_entities(id) ON DELETE CASCADE,
        FOREIGN KEY (source_memory_id) REFERENCES memories(id) ON DELETE SET NULL
    );
    """,
    "CREATE INDEX IF NOT EXISTS idx_entity_relationships_source ON entity_relationships(source_entity_id);",
    "CREATE INDEX IF NOT EXISTS idx_entity_relationships_target ON entity_relationships(target_entity_id);",
    "CREATE INDEX IF NOT EXISTS idx_entity_relationships_type ON entity_relationships(relationship);",
    "CREATE INDEX IF NOT EXISTS idx_entity_relationships_user ON entity_relationships(user_name);",
]),
```

Do NOT remove old entity types from ExtractedEntity -- they coexist with new types and will age out naturally.
  </action>
  <verify>
Run `python -c "from daem0nmcp.models import EntityAlias, EntityRelationship, PERSONAL_ENTITY_TYPES, ENTITY_RELATIONSHIP_TYPES; print(len(PERSONAL_ENTITY_TYPES), len(ENTITY_RELATIONSHIP_TYPES))"` -- should print "5 14".

Run `python -c "from daem0nmcp.migrations.schema import MIGRATIONS; print(MIGRATIONS[-1][0], MIGRATIONS[-1][1])"` -- should print "19" and the description.
  </verify>
  <done>EntityAlias and EntityRelationship models importable from models.py, PERSONAL_ENTITY_TYPES has 5 types, ENTITY_RELATIONSHIP_TYPES has 14 types, migration 19 exists with CREATE TABLE statements for both new tables.</done>
</task>

<task type="auto">
  <name>Task 2: Replace code-entity extraction with personal-entity patterns and add alias-aware resolution</name>
  <files>daem0nmcp/entity_extractor.py, daem0nmcp/graph/entity_resolver.py, daem0nmcp/entity_manager.py</files>
  <action>
In daem0nmcp/entity_extractor.py:

1. Replace the entire PATTERNS dict and STOP_WORDS with personal entity patterns:

```python
# Personal entity extraction patterns (Phase 7: conversational, not code)
PERSONAL_PATTERNS = {
    # Person names: Capitalized proper nouns (2+ chars), optional title
    # Matches: "Sarah", "John Smith", "Dr. Williams"
    "person": re.compile(
        r'\b(?:(?:Dr|Mr|Mrs|Ms|Prof)\.?\s+)?'
        r'([A-Z][a-z]{1,}(?:\s+[A-Z][a-z]{1,}){0,2})\b'
    ),

    # Pet names: after possessive + pet word
    # Matches: "my dog Max", "her cat Luna"
    "pet": re.compile(
        r'(?:my|his|her|their|our)\s+(?:dog|cat|pet|bird|fish|hamster|rabbit|parrot|turtle|horse)\s+'
        r'([A-Z][a-z]+)\b',
        re.IGNORECASE
    ),

    # Relationship references: "my sister", "his mom"
    # These produce aliases, not entities directly -- extracted as "relationship_ref" type
    "relationship_ref": re.compile(
        r'\b((?:my|his|her|their|our)\s+'
        r'(?:mom|mother|dad|father|sister|brother|wife|husband|'
        r'partner|boyfriend|girlfriend|son|daughter|friend|boss|coworker|neighbor|'
        r'aunt|uncle|cousin|grandma|grandmother|grandpa|grandfather|'
        r'niece|nephew|roommate|fiance|fiancee))\b',
        re.IGNORECASE
    ),
}

# Common first names and words that are NOT entities (false positive filter)
STOP_WORDS = frozenset({
    "the", "and", "for", "with", "use", "get", "set", "add", "new",
    "this", "that", "from", "have", "been", "will", "can", "should",
    "just", "also", "very", "much", "some", "any", "all", "but",
    "not", "what", "when", "where", "how", "why", "who", "which",
    "would", "could", "there", "about", "like", "into", "over",
    "then", "them", "been", "being", "having", "doing", "going",
    "today", "tomorrow", "yesterday", "monday", "tuesday", "wednesday",
    "thursday", "friday", "saturday", "sunday", "january", "february",
    "march", "april", "may", "june", "july", "august", "september",
    "october", "november", "december",
})
```

Keep PATTERNS as an alias: `PATTERNS = PERSONAL_PATTERNS` (for backward compat if anything references it).

2. Update the EntityExtractor class:
   - Change `__init__` to use `PERSONAL_PATTERNS` as default.
   - Update the class docstring to describe personal entity types.
   - Update `extract_concepts` to be a no-op that returns `[]` (code concepts not relevant for personal entities).

In daem0nmcp/graph/entity_resolver.py:

3. Add alias resolution to the `resolve()` method. After the cache check and before database creation of a new entity, add an alias lookup step:

```python
# Check alias table for alternative references
from ..models import EntityAlias
alias_result = await sess.execute(
    select(EntityAlias).where(
        func.lower(EntityAlias.alias) == normalized,
        EntityAlias.user_name == user_name_param,  # need user_name passed through
    )
)
alias_match = alias_result.scalar_one_or_none()
if alias_match:
    # Resolve to the canonical entity
    self._canonical_cache[cache_key] = alias_match.entity_id
    return alias_match.entity_id, False
```

To support this, add a `user_name` parameter to `resolve()` with default "default". The cache key should remain as-is since aliases resolve through the entity's type+name.

4. Update `normalize()` to add personal entity normalization rules:
   - For "person": lowercase, strip titles (Dr./Mr./Mrs./Ms./Prof.)
   - For "pet": lowercase
   - For "place": lowercase
   - For "organization": lowercase
   - For "relationship_ref": lowercase, strip possessive ("my sister" -> "sister")
   - Keep all existing code-entity normalization rules (they still work for old data)

In daem0nmcp/entity_manager.py:

5. Add methods for alias management and entity-entity relationships:

```python
async def add_alias(
    self,
    entity_id: int,
    alias: str,
    alias_type: str,
    user_name: str = "default",
) -> int:
    """Create an alias for an entity. Returns alias ID."""

async def add_entity_relationship(
    self,
    source_entity_id: int,
    target_entity_id: int,
    relationship: str,
    description: str = None,
    source_memory_id: int = None,
    user_name: str = "default",
) -> int:
    """Create a relationship between two entities. Returns relationship ID.
    Validates relationship type against ENTITY_RELATIONSHIP_TYPES."""
```

6. Update `process_memory()` to handle "relationship_ref" type extractions by logging them (not creating standalone entities). When a relationship_ref is found alongside a person name in the same memory, create an alias linking the person entity to the relationship reference.

For example, if "my sister Sarah" is in the content:
- Extract person "Sarah" and create/resolve entity
- Extract relationship_ref "my sister"
- Create alias: entity=Sarah, alias="my sister", alias_type="relationship"

Pass `user_name` through to `self.resolver.resolve()`.

7. Update `_get_or_create_entity()` to also pass `user_name` to the resolver.
  </action>
  <verify>
Run `python -c "from daem0nmcp.entity_extractor import EntityExtractor; e = EntityExtractor(); results = e.extract_entities('My sister Sarah lives in Portland with her dog Max'); print([(r['type'], r['name']) for r in results])"` -- should show person:Sarah, relationship_ref:my sister (or similar), pet:Max.

Run `python -c "from daem0nmcp.graph.entity_resolver import EntityResolver; print('resolve' in dir(EntityResolver))"` -- should print True.

Run `python -c "from daem0nmcp.entity_manager import EntityManager; print('add_alias' in dir(EntityManager), 'add_entity_relationship' in dir(EntityManager))"` -- should print "True True".

Run existing tests: `python -m pytest tests/ -x -q --timeout=30 2>&1 | tail -5` -- no NEW test failures introduced (pre-existing failures are expected).
  </verify>
  <done>EntityExtractor extracts personal entities (person, pet, relationship_ref) from conversational text. EntityResolver checks alias table before creating new entities. EntityManager has add_alias and add_entity_relationship methods. Relationship references co-occurring with person names in the same memory create aliases. Existing tests do not regress.</done>
</task>

</tasks>

<verification>
1. Import check: `python -c "from daem0nmcp.models import EntityAlias, EntityRelationship, PERSONAL_ENTITY_TYPES, ENTITY_RELATIONSHIP_TYPES; print('Models OK')"` succeeds
2. Extraction check: EntityExtractor produces person/pet/relationship_ref entities from personal text
3. Migration check: Migration 19 exists in MIGRATIONS list with correct SQL
4. Resolver check: EntityResolver.resolve() accepts user_name parameter and checks aliases
5. Manager check: EntityManager has add_alias() and add_entity_relationship() methods
6. No regressions: `python -m pytest tests/ -x -q --timeout=30` shows no new failures
</verification>

<success_criteria>
- EntityAlias and EntityRelationship models defined in models.py with proper ForeignKeys and cascading deletes
- PERSONAL_ENTITY_TYPES (5 types) and ENTITY_RELATIONSHIP_TYPES (14 types) constants exported
- Migration 19 creates entity_aliases and entity_relationships tables with proper indexes
- EntityExtractor uses personal patterns (person, pet, relationship_ref) instead of code patterns
- EntityResolver checks alias table during resolution before creating new entities
- EntityManager can create aliases and entity-to-entity relationships
- process_memory creates aliases when relationship references co-occur with person names
</success_criteria>

<output>
After completion, create `.planning/phases/07-knowledge-graph-adaptation/07-01-SUMMARY.md`
</output>
