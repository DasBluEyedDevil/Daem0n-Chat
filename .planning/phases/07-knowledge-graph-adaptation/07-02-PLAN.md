---
phase: 07-knowledge-graph-adaptation
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - daem0nmcp/graph/knowledge_graph.py
  - daem0nmcp/tools/daem0n_relate.py
  - daem0nmcp/tools/daem0n_briefing.py
  - tests/test_knowledge_graph_personal.py
autonomous: true

must_haves:
  truths:
    - "Multi-hop relational queries traverse entity-entity edges to answer questions like 'my sister's dog'"
    - "daem0n_relate has a 'query' action that accepts relational questions and returns entity info + memories"
    - "Knowledge graph loads entity-entity relationships alongside existing memory-entity edges"
    - "Claude receives guidance to track its own statements via claude_said/claude_commitment tags"
    - "Tests prove multi-hop traversal, alias resolution, and entity relationship queries work"
  artifacts:
    - path: "daem0nmcp/graph/knowledge_graph.py"
      provides: "Entity-entity edge loading and multi-hop relational query method"
      contains: "query_relational"
    - path: "daem0nmcp/tools/daem0n_relate.py"
      provides: "query action on daem0n_relate tool"
      contains: "query"
    - path: "daem0nmcp/tools/daem0n_briefing.py"
      provides: "Claude statement tracking guidance in briefing"
      contains: "claude_said"
    - path: "tests/test_knowledge_graph_personal.py"
      provides: "Tests for personal knowledge graph features"
      min_lines: 100
  key_links:
    - from: "daem0nmcp/tools/daem0n_relate.py"
      to: "daem0nmcp/graph/knowledge_graph.py"
      via: "query action calls query_relational"
      pattern: "query_relational"
    - from: "daem0nmcp/graph/knowledge_graph.py"
      to: "daem0nmcp/models.py"
      via: "_load_from_db loads EntityRelationship rows"
      pattern: "EntityRelationship"
    - from: "daem0nmcp/graph/knowledge_graph.py"
      to: "daem0nmcp/models.py"
      via: "query_relational resolves aliases via EntityAlias"
      pattern: "EntityAlias"
---

<objective>
Add multi-hop relational query capability to the knowledge graph and expose it through the daem0n_relate tool, plus Claude statement tracking guidance and comprehensive tests.

Purpose: This plan completes Phase 7 by making the personal knowledge graph queryable. Users can ask "What do you know about my sister's dog?" and get accurate traversal through entity relationships. Claude also receives guidance to track its own commitments.

Output: Working multi-hop queries via daem0n_relate query action, entity-entity edges in the graph, Claude statement tracking guidance in briefing, 10+ tests.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-knowledge-graph-adaptation/07-RESEARCH.md
@.planning/phases/07-knowledge-graph-adaptation/07-01-SUMMARY.md
@daem0nmcp/graph/knowledge_graph.py
@daem0nmcp/graph/entity_resolver.py
@daem0nmcp/tools/daem0n_relate.py
@daem0nmcp/tools/daem0n_briefing.py
@daem0nmcp/models.py
@daem0nmcp/entity_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add entity-entity edge loading and multi-hop query to KnowledgeGraph, update daem0n_relate with query action, add Claude statement tracking to briefing</name>
  <files>daem0nmcp/graph/knowledge_graph.py, daem0nmcp/tools/daem0n_relate.py, daem0nmcp/tools/daem0n_briefing.py</files>
  <action>
In daem0nmcp/graph/knowledge_graph.py:

1. Update `_load_from_db()` to add a 4th loading step for entity-entity relationships. After the existing step 3 (MemoryRelationship loading), add:

```python
# 4. Load entity-entity relationships (Phase 7: personal knowledge graph)
from ..models import EntityRelationship as EntityRelModel
ent_rel_result = await session.execute(select(EntityRelModel))
entity_rels = ent_rel_result.scalars().all()

for rel in entity_rels:
    source_node = f"entity:{rel.source_entity_id}"
    target_node = f"entity:{rel.target_entity_id}"

    # Only add edge if both entity nodes exist
    if self._graph.has_node(source_node) and self._graph.has_node(target_node):
        self._graph.add_edge(
            source_node,
            target_node,
            edge_type="entity_relationship",
            relationship=rel.relationship,
            description=rel.description,
            confidence=rel.confidence,
        )

logger.debug(f"Loaded {len(entity_rels)} entity-entity relationships")
```

2. Add `query_relational()` method to KnowledgeGraph class. This is the multi-hop traversal engine:

```python
async def query_relational(
    self,
    query_parts: List[str],
    user_name: str = "default",
) -> Dict[str, Any]:
    """
    Multi-hop relational query traversing entity-entity edges.

    Decomposes "my sister's dog" into ["my sister", "dog"] and:
    1. Resolves "my sister" via alias table -> entity (e.g., Sarah)
    2. From Sarah, finds connected entities matching "dog" (by type or name)
    3. Returns terminal entity + all memories referencing it

    Args:
        query_parts: List of entity references to traverse, e.g. ["my sister", "dog"]
        user_name: User scope for alias resolution

    Returns:
        Dict with found, entity info, memories, and traversal path
    """
    await self.ensure_loaded()

    if not query_parts:
        return {"found": False, "error": "No query parts provided"}

    from sqlalchemy import select, func
    from ..models import EntityAlias, ExtractedEntity, Memory

    traversal_path = []

    # Step 1: Resolve first reference via alias table or direct name match
    current_entity_id = await self._resolve_reference(query_parts[0], user_name)
    if current_entity_id is None:
        return {"found": False, "error": f"Unknown reference: '{query_parts[0]}'"}

    current_node = f"entity:{current_entity_id}"
    attrs = self.get_node_attributes(current_node)
    traversal_path.append(attrs.get("name", str(current_entity_id)) if attrs else str(current_entity_id))

    # Step 2: For each subsequent part, traverse to matching connected entity
    for part in query_parts[1:]:
        connected_id = self._find_connected_match(current_entity_id, part)
        if connected_id is None:
            return {
                "found": False,
                "error": f"No '{part}' connected to '{traversal_path[-1]}'",
                "partial_path": traversal_path,
            }
        current_entity_id = connected_id
        node = f"entity:{current_entity_id}"
        attrs = self.get_node_attributes(node)
        traversal_path.append(attrs.get("name", str(current_entity_id)) if attrs else str(current_entity_id))

    # Step 3: Gather memories for terminal entity
    memory_ids = self.get_memories_for_entity(current_entity_id)
    terminal_attrs = self.get_node_attributes(f"entity:{current_entity_id}")

    # Fetch memory content from DB
    memories_data = []
    if memory_ids:
        async with self._db.get_session() as session:
            result = await session.execute(
                select(Memory).where(Memory.id.in_(memory_ids))
            )
            memories = result.scalars().all()
            for m in memories:
                memories_data.append({
                    "id": m.id,
                    "content": m.content,
                    "categories": m.categories,
                    "created_at": m.created_at.isoformat() if m.created_at else None,
                })

    return {
        "found": True,
        "entity": {
            "id": current_entity_id,
            "name": terminal_attrs.get("name") if terminal_attrs else None,
            "type": terminal_attrs.get("entity_type") if terminal_attrs else None,
        },
        "memories": memories_data,
        "path": traversal_path,
    }
```

3. Add two private helper methods:

```python
async def _resolve_reference(self, reference: str, user_name: str) -> Optional[int]:
    """Resolve a reference string to an entity ID via alias table or direct name match."""
    from sqlalchemy import select, func
    from ..models import EntityAlias, ExtractedEntity

    ref_lower = reference.lower().strip()

    async with self._db.get_session() as session:
        # Try alias lookup first
        alias_result = await session.execute(
            select(EntityAlias).where(
                func.lower(EntityAlias.alias) == ref_lower,
                EntityAlias.user_name == user_name,
            )
        )
        alias = alias_result.scalar_one_or_none()
        if alias:
            return alias.entity_id

        # Try direct entity name match
        entity_result = await session.execute(
            select(ExtractedEntity).where(
                func.lower(ExtractedEntity.name) == ref_lower,
                ExtractedEntity.user_name == user_name,
            )
        )
        entity = entity_result.scalar_one_or_none()
        if entity:
            return entity.id

    return None

def _find_connected_match(self, entity_id: int, search_term: str) -> Optional[int]:
    """Find an entity connected to entity_id that matches search_term by type or name."""
    entity_node = f"entity:{entity_id}"
    if not self._graph.has_node(entity_node):
        return None

    search_lower = search_term.lower().strip()

    # Check all neighbors (both directions for entity-entity edges)
    neighbors = set()
    for succ in self._graph.successors(entity_node):
        if succ.startswith("entity:"):
            neighbors.add(succ)
    for pred in self._graph.predecessors(entity_node):
        if pred.startswith("entity:"):
            neighbors.add(pred)

    for neighbor in neighbors:
        attrs = self._graph.nodes.get(neighbor, {})
        # Match by entity_type (e.g., "dog" matches entity_type="pet")
        entity_type = (attrs.get("entity_type") or "").lower()
        entity_name = (attrs.get("name") or "").lower()

        # Check type match: "dog" -> "pet", or direct type match
        pet_words = {"dog", "cat", "pet", "bird", "fish", "hamster", "rabbit", "parrot", "turtle", "horse"}
        if search_lower in pet_words and entity_type == "pet":
            return int(neighbor.split(":")[1])
        if search_lower == entity_type:
            return int(neighbor.split(":")[1])
        # Check name match
        if search_lower == entity_name or search_lower in entity_name:
            return int(neighbor.split(":")[1])

    return None
```

Add necessary imports at top of file: `Optional` from typing (if not already present).

In daem0nmcp/tools/daem0n_relate.py:

4. Add "query" to VALID_ACTIONS:
```python
VALID_ACTIONS = {"link", "unlink", "related", "graph", "communities", "query"}
```

5. Add a `query_parts` parameter to the tool signature:
```python
async def daem0n_relate(
    action: str,
    memory_id: Optional[int] = None,
    target_id: Optional[int] = None,
    relationship: Optional[str] = None,
    entity_name: Optional[str] = None,
    query_parts: Optional[List[str]] = None,  # NEW: for query action
    user_id: Optional[str] = None,
) -> Dict[str, Any]:
```

6. Add the query handler in the action dispatch (before the final return):
```python
elif action == "query":
    if not query_parts:
        return {"error": "query requires query_parts (list of entity references to traverse)"}
    kg = await ctx.memory_manager.get_knowledge_graph()
    return await kg.query_relational(
        query_parts=query_parts,
        user_name=ctx.current_user,
    )
```

7. Update the tool docstring to mention the query action:
```
Manage relationships between memories and entities. Actions: 'link'
(connect two memories), 'unlink', 'related' (find related memories),
'graph' (get knowledge graph view), 'communities' (list memory communities),
'query' (multi-hop relational query, e.g. query_parts=["my sister", "dog"]).
```

In daem0nmcp/tools/daem0n_briefing.py:

8. Add Claude statement tracking guidance to the briefing output. In the section that builds the briefing response (inside the function that constructs the briefing dict), add a "claude_statement_tracking" key to the returned briefing dict. This should be a static guidance string:

```python
briefing["claude_statement_tracking"] = (
    "Track your own commitments and opinions by storing them as memories. "
    "When you make a promise ('I'll remind you'), share an opinion, or ask a question "
    "that needs follow-up, use daem0n_remember with tags=['claude_said'] or "
    "tags=['claude_commitment'] alongside the appropriate category. "
    "This ensures you can recall what YOU said, not just what the user said."
)
```

Find the appropriate location in _build_briefing or the main briefing function where the response dict is assembled, and add this key. It should appear in ALL briefing paths (new device, unnamed user, returning user).

Add `List` to the imports from typing in daem0n_relate if not already imported.
  </action>
  <verify>
Run `python -c "from daem0nmcp.graph.knowledge_graph import KnowledgeGraph; print('query_relational' in dir(KnowledgeGraph))"` -- should print True.

Run `python -c "from daem0nmcp.tools.daem0n_relate import VALID_ACTIONS; print('query' in VALID_ACTIONS)"` -- should print True.

Run existing tests: `python -m pytest tests/ -x -q --timeout=30 2>&1 | tail -5` -- no NEW test failures.
  </verify>
  <done>KnowledgeGraph loads entity-entity edges in _load_from_db, has query_relational method for multi-hop traversal, and _resolve_reference/_find_connected_match helpers. daem0n_relate has "query" action accepting query_parts. Briefing includes claude_statement_tracking guidance. No test regressions.</done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive tests for personal knowledge graph features</name>
  <files>tests/test_knowledge_graph_personal.py</files>
  <action>
Create tests/test_knowledge_graph_personal.py with the following test cases. Use the project's existing async test patterns (pytest-asyncio, tempfile-based DatabaseManager, direct model insertion via session).

Test infrastructure setup:
- Use a temp directory for DatabaseManager
- Call db.init_db() to create tables (SQLAlchemy creates from models)
- Insert test data directly via session (ExtractedEntity, MemoryEntityRef, EntityAlias, EntityRelationship, Memory)
- Create KnowledgeGraph and EntityManager instances

Tests to write (at least 10):

**EntityExtractor tests (3):**
1. `test_extract_person_names` -- "Sarah" and "John Smith" extracted as person type from "I talked to Sarah and John Smith today"
2. `test_extract_pet_names` -- "Max" extracted as pet type from "My dog Max loves the park"
3. `test_extract_relationship_refs` -- "my sister" extracted as relationship_ref from "my sister called me yesterday"

**EntityAlias and Resolution tests (3):**
4. `test_alias_model_creation` -- EntityAlias can be created with entity_id, alias, alias_type, user_name
5. `test_resolver_finds_alias` -- EntityResolver.resolve() returns existing entity when alias matches (insert entity + alias, then resolve by alias string)
6. `test_entity_relationship_model` -- EntityRelationship can be created linking two entities with a relationship type

**KnowledgeGraph multi-hop tests (4+):**
7. `test_graph_loads_entity_relationships` -- After inserting entities + EntityRelationship rows, KnowledgeGraph._load_from_db creates edges between entity nodes
8. `test_query_relational_single_hop` -- query_relational(["Sarah"]) finds entity and returns memories
9. `test_query_relational_multi_hop` -- query_relational(["my sister", "dog"]) traverses alias -> entity -> pet entity. Setup: entity Sarah (person), alias "my sister"->Sarah, entity Max (pet), EntityRelationship Sarah->Max (owns), memory referencing Max. Should return Max entity + memory.
10. `test_query_relational_not_found` -- query_relational(["unknown person"]) returns found=False with error

**Tool integration test (1):**
11. `test_relate_query_action_valid` -- VALID_ACTIONS includes "query"

Use `@pytest.mark.asyncio` for async tests. Use the DatabaseManager + session pattern from existing tests. Each test should be self-contained (create its own test data).

Focus on the critical path: alias resolution + multi-hop traversal is the riskiest part and needs the most coverage.
  </action>
  <verify>
Run `python -m pytest tests/test_knowledge_graph_personal.py -v --timeout=30` -- all tests pass.

Run `python -m pytest tests/test_knowledge_graph_personal.py -v --timeout=30 2>&1 | grep -c "PASSED"` -- should be >= 10.
  </verify>
  <done>tests/test_knowledge_graph_personal.py exists with 10+ passing tests covering: personal entity extraction (person, pet, relationship_ref), alias model creation, alias-aware resolution, entity-entity relationships, graph loading of entity-entity edges, single-hop query, multi-hop query traversal, query not-found, and tool action validation.</done>
</task>

</tasks>

<verification>
1. Graph loading: KnowledgeGraph._load_from_db loads 4 types (entities, memory-entity refs, memory-memory rels, entity-entity rels)
2. Multi-hop query: query_relational(["my sister", "dog"]) traverses alias -> person entity -> pet entity
3. Tool integration: daem0n_relate query action delegates to KnowledgeGraph.query_relational
4. Claude tracking: Briefing includes claude_statement_tracking guidance in all paths
5. Tests: `python -m pytest tests/test_knowledge_graph_personal.py -v --timeout=30` -- 10+ tests pass
6. No regressions: `python -m pytest tests/ -x -q --timeout=30` -- no new failures
</verification>

<success_criteria>
- KnowledgeGraph._load_from_db has 4th step loading EntityRelationship as entity-entity edges
- query_relational method resolves aliases, traverses entity-entity edges, gathers memories for terminal entity
- _resolve_reference checks alias table first, then direct name match
- _find_connected_match searches entity neighbors by type (pet words -> pet type) and name
- daem0n_relate "query" action works with query_parts parameter
- Briefing includes claude_statement_tracking guidance string in all briefing paths
- 10+ tests pass covering extraction, alias resolution, multi-hop queries, and tool integration
- Phase 7 success criteria met: personal entities stored, multi-hop recall works, entity resolution merges references via aliases
</success_criteria>

<output>
After completion, create `.planning/phases/07-knowledge-graph-adaptation/07-02-SUMMARY.md`
</output>
