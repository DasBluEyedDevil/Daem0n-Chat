---
phase: 05-session-experience
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - daem0nmcp/tools/daem0n_briefing.py
  - tests/test_daem0n_tools.py
autonomous: true

must_haves:
  truths:
    - "Unresolved threads are prioritized by category weight, recency, and importance -- not just chronological order"
    - "Threads older than 90 days are excluded from the briefing"
    - "Each unresolved thread has a follow_up_type indicating how Claude should bring it up (check_in, gentle_ask, progress, etc.)"
    - "Briefing includes thread_surfacing_guidance for mid-conversation follow-up on threads not in the greeting"
    - "Top 2-3 threads include recurring_since duration when topic has been mentioned before"
  artifacts:
    - path: "daem0nmcp/tools/daem0n_briefing.py"
      provides: "Priority-scored thread detection, follow-up types, surfacing guidance, duration tracking"
      contains: "_get_unresolved_threads"
    - path: "tests/test_daem0n_tools.py"
      provides: "Tests for thread prioritization, follow-up types, stale exclusion, surfacing guidance, duration"
  key_links:
    - from: "daem0nmcp/tools/daem0n_briefing.py (_get_unresolved_threads)"
      to: "briefing response unresolved_threads"
      via: "replaces inline thread detection in _build_user_briefing"
      pattern: "_get_unresolved_threads"
    - from: "daem0nmcp/tools/daem0n_briefing.py (_build_thread_surfacing_guidance)"
      to: "briefing response thread_surfacing_guidance"
      via: "called in _build_user_briefing after greeting_guidance"
      pattern: "thread_surfacing_guidance"
    - from: "daem0nmcp/tools/daem0n_briefing.py (_compute_thread_duration)"
      to: "unresolved thread recurring_since field"
      via: "semantic recall on thread content to find earliest mention"
      pattern: "recurring_since"
---

<objective>
Improve unresolved thread detection with priority scoring, follow-up types, stale thread exclusion, mid-conversation surfacing guidance, and recurring theme duration tracking.

Purpose: Enable the system to detect which unresolved threads matter most, tell Claude HOW and WHEN to follow up on them (not just WHAT they are), surface lower-priority threads at natural moments during conversation rather than cramming everything into the greeting, and identify long-running concerns ("you've been worried about this for a month").

Output: Enhanced `_get_unresolved_threads()` with priority scoring, `_build_thread_surfacing_guidance()`, `_compute_thread_duration()`, follow-up type classification, 90-day staleness cutoff, tests.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-session-experience/05-RESEARCH.md
@.planning/phases/05-session-experience/05-01-SUMMARY.md
@daem0nmcp/tools/daem0n_briefing.py
@daem0nmcp/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor thread detection with priority scoring, follow-up types, and surfacing guidance</name>
  <files>daem0nmcp/tools/daem0n_briefing.py</files>
  <action>
**Refactor the inline unresolved thread detection** (currently lines ~227-246 in `_build_user_briefing()`) into a dedicated `_get_unresolved_threads()` async function. This function:

1. Queries memories where `outcome IS NULL`, not archived, matching the user_name. Fetches up to 30 candidates (more than the current 20, to allow filtering).

2. Filters to only include memories with categories containing "concern", "goal", "context", or "event".

3. **Excludes stale threads**: Skip any thread where `days_ago > 90`. These are probably resolved silently.

4. **Computes priority score** for each thread:
   - Category weight: concern=3.0, goal=2.0, event=1.5, context=1.0
   - Recency multiplier: <=7 days = 1.5x, 8-30 days = 1.0x, 31-90 days = 0.5x
   - Importance multiplier: is_permanent = 1.2x
   - Final priority = category_weight * recency * importance

5. **Assigns follow_up_type** via `_get_follow_up_type(category, days_ago)`:
   - concern + <=3 days: "check_in"
   - concern + 4-14 days: "gentle_ask"
   - concern + >14 days: "open_ended"
   - goal + <=7 days: "progress"
   - goal + >7 days: "reconnect"
   - event + <=3 days: "outcome"
   - else: "casual"

6. Each thread dict includes: `id`, `summary` (using existing `_summarize()`), `category` (primary), `days_ago`, `time_ago` (using `_humanize_timedelta` from Plan 05-01), `priority`, `follow_up_type`.

7. Sorts by priority descending, returns top `limit` (default 5).

**Replace the inline thread detection block** in `_build_user_briefing()` with a call to `_get_unresolved_threads(ctx, user_name)`. Wire up the `memory_ids` collection from the returned threads.

**Add `_compute_thread_duration()`** async function:
- Takes `ctx`, `user_name`, and `thread_content` string
- Calls `ctx.memory_manager.recall()` with that content as topic, limit=5, scoped to user
- Finds the oldest `created_at` among returned memories
- If oldest is >=7 days old and there are >=2 memories, returns `_humanize_timedelta(oldest_created)`
- Otherwise returns None
- Use `asyncio.gather()` to run duration queries concurrently for the top 2 threads only (to avoid latency)

**Add the `recurring_since` field** to the top 2 threads returned by `_get_unresolved_threads()`:
- After getting threads, run `_compute_thread_duration()` for threads[0:2] concurrently
- Add `"recurring_since": result` to each of those thread dicts

**Create `_build_thread_surfacing_guidance()`** function:
- Takes the full `unresolved_threads` list
- Skips the first 2 threads (those go in greeting_guidance from Plan 05-01)
- For the remaining threads (up to 3), builds guidance text telling Claude to look for natural moments to follow up
- Includes the `follow_up_type` for each
- Includes instruction: "Don't force these -- wait for a relevant moment or natural pause"
- Includes instruction: "If the user says something is resolved, call daem0n_reflect(action='outcome') to record it"
- Returns None if no remaining threads

**Call `_build_thread_surfacing_guidance()`** in `_build_user_briefing()` after the greeting_guidance is built. Add the result as `response["thread_surfacing_guidance"]` (only if not None).
  </action>
  <verify>
Run `python -c "from daem0nmcp.tools.daem0n_briefing import _get_follow_up_type; print(_get_follow_up_type('concern', 2)); print(_get_follow_up_type('goal', 10)); print(_get_follow_up_type('event', 1))"` and confirm it prints "check_in", "reconnect", "outcome".
  </verify>
  <done>
`_get_unresolved_threads()` returns priority-scored threads with follow_up_type and 90-day cutoff. Top 2 threads have `recurring_since` duration. `_build_thread_surfacing_guidance()` generates mid-conversation follow-up guidance. Inline thread detection replaced.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests for thread prioritization, follow-up types, stale exclusion, and surfacing guidance</name>
  <files>tests/test_daem0n_tools.py</files>
  <action>
Add tests to the `TestSessionExperience` class (created in Plan 05-01) or create a new `TestThreadDetection` class. Tests needed:

1. `test_get_follow_up_type_concern_fresh` -- concern at 2 days returns "check_in"
2. `test_get_follow_up_type_concern_moderate` -- concern at 10 days returns "gentle_ask"
3. `test_get_follow_up_type_concern_old` -- concern at 20 days returns "open_ended"
4. `test_get_follow_up_type_goal_fresh` -- goal at 5 days returns "progress"
5. `test_get_follow_up_type_goal_old` -- goal at 14 days returns "reconnect"
6. `test_get_follow_up_type_event_fresh` -- event at 1 day returns "outcome"
7. `test_get_follow_up_type_default` -- context at 10 days returns "casual"
8. `test_stale_threads_excluded` -- Create mock memories with one >90 days old. Run through the thread detection. Verify the >90 day thread is NOT in the results.
9. `test_thread_priority_ordering` -- Create mock memories: a 2-day-old concern and a 14-day-old goal. Verify the concern ranks higher (priority score is higher).
10. `test_thread_surfacing_guidance_skips_top_two` -- Given 4 unresolved threads, verify `_build_thread_surfacing_guidance()` returns guidance mentioning only threads 3-4, not threads 1-2.
11. `test_thread_surfacing_guidance_none_when_few` -- Given 2 or fewer threads, verify `_build_thread_surfacing_guidance()` returns None.
12. `test_briefing_contains_thread_surfacing_guidance` -- Full integration: mock a returning user with 4+ unresolved threads, verify briefing response contains `thread_surfacing_guidance` key.

For tests 8-9 and 12, follow the existing `TestDaem0nBriefing` mocking patterns with `patch("daem0nmcp.tools.daem0n_briefing.get_user_context")` and mock database sessions.

For the `_get_follow_up_type` tests (1-7), import it directly and test as a pure function.

For `_build_thread_surfacing_guidance` tests (10-11), import it directly and pass mock thread dicts.

Run `pytest tests/test_daem0n_tools.py -x -q` to verify all tests pass with no regressions.
  </action>
  <verify>Run `pytest tests/test_daem0n_tools.py::TestThreadDetection -v` (or `TestSessionExperience` if combined) and confirm all 12 tests pass. Also run `pytest tests/test_daem0n_tools.py -x -q` to confirm no regressions.</verify>
  <done>
12 new tests pass covering follow-up type classification, stale thread exclusion, priority ordering, thread surfacing guidance logic, and full briefing integration with surfacing guidance. No regressions in existing tests.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/test_daem0n_tools.py -x -q` -- all tests pass, no regressions
2. Briefing for returning user with multiple unresolved threads shows threads sorted by priority (not chronological)
3. Threads >90 days old do not appear in briefing unresolved_threads
4. Each thread has follow_up_type field
5. Top threads have recurring_since when topic was mentioned before
6. Briefing contains thread_surfacing_guidance when >2 unresolved threads exist
7. thread_surfacing_guidance mentions only threads NOT already in greeting_guidance
</verification>

<success_criteria>
- Unresolved threads sorted by priority score, not just recency
- Concerns within 7 days rank highest, stale threads (>90 days) excluded
- Each thread has a follow_up_type guiding Claude on HOW to bring it up
- Thread surfacing guidance tells Claude to follow up on remaining threads at natural moments
- Top 2 threads enriched with recurring_since duration context
- 12 new tests pass, 0 regressions
</success_criteria>

<output>
After completion, create `.planning/phases/05-session-experience/05-02-SUMMARY.md`
</output>
