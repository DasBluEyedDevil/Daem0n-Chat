---
phase: 06-conversation-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - daem0nmcp/emotion_detect.py
  - daem0nmcp/tools/daem0n_remember.py
  - tests/test_daem0n_tools.py
autonomous: true

must_haves:
  truths:
    - "System detects explicit emotional statements ('I'm stressed', 'I feel excited') with high confidence"
    - "System detects emphasis patterns (ALL CAPS, multiple exclamation marks) as emotional signals"
    - "System detects topic sentiment (heavy topics like 'funeral', positive topics like 'promotion') as inferred emotional context"
    - "Common acronyms (AI, SQL, API, etc.) are NOT flagged as emphasis"
    - "Memories stored via daem0n_remember are auto-enriched with emotion category and emotion tags when emotional signal is detected"
    - "Explicit 'remember this' memories AND auto-detected memories both receive emotion enrichment"
  artifacts:
    - path: "daem0nmcp/emotion_detect.py"
      provides: "Rule-based emotion detection with three methods"
      exports: ["detect_emotion"]
    - path: "daem0nmcp/tools/daem0n_remember.py"
      provides: "Emotion enrichment pipeline before memory storage"
      contains: "detect_emotion"
    - path: "tests/test_daem0n_tools.py"
      provides: "Tests for emotion detection and enrichment"
  key_links:
    - from: "daem0nmcp/emotion_detect.py (detect_emotion)"
      to: "daem0nmcp/tools/daem0n_remember.py"
      via: "called before ctx.memory_manager.remember() to enrich categories and tags"
      pattern: "detect_emotion"
    - from: "daem0nmcp/tools/daem0n_remember.py (emotion enrichment)"
      to: "Memory storage (categories + tags)"
      via: "adds 'emotion' to categories list and 'emotion:{label}' + 'valence:{valence}' to tags"
      pattern: "emotion:"
---

<objective>
Create a rule-based emotion detection module and wire it into the memory storage pipeline so that memories are automatically enriched with emotional context.

Purpose: CONV-02 requires memories to store emotional context alongside facts, and CONV-03 requires detecting emotion from conversation clues (explicit statements, emphasis patterns, topic sentiment). This plan delivers both capabilities by detecting emotion at storage time and enriching memories with emotion metadata.

Output: `daem0nmcp/emotion_detect.py` with `detect_emotion()`, enrichment pipeline in `daem0n_remember.py`, tests.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-conversation-intelligence/06-RESEARCH.md
@daem0nmcp/tools/daem0n_remember.py
@daem0nmcp/auto_detect.py
@daem0nmcp/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create emotion detection module with three detection methods</name>
  <files>daem0nmcp/emotion_detect.py</files>
  <action>
Create `daem0nmcp/emotion_detect.py` with a single public function `detect_emotion(content: str) -> Optional[Dict]`.

The module implements three detection methods, checked in priority order (highest confidence first):

**1. Explicit emotional statements (confidence 0.95):**
- Match patterns like "I'm stressed", "I am so excited", "I feel worried", "I'm really anxious"
- Use compiled regex patterns: `r'\bi(?:\'m| am) (?:so |really |very |super )?{word}\b'` and `r'\bi feel (?:so |really |very )?{word}\b'` (case insensitive)
- Two frozensets of emotion words:
  - POSITIVE_EMOTIONS: ~20 words (happy, excited, thrilled, grateful, relieved, proud, delighted, hopeful, optimistic, joyful, pleased, content, satisfied, enthusiastic, pumped, stoked, elated, overjoyed, amazed, ecstatic)
  - NEGATIVE_EMOTIONS: ~22 words (sad, stressed, anxious, worried, frustrated, angry, upset, depressed, overwhelmed, scared, terrified, nervous, disappointed, heartbroken, lonely, exhausted, furious, miserable, devastated, annoyed, irritated, dreading)
- Returns: `{"emotion_label": "{word}", "valence": "positive"|"negative", "source": "explicit", "confidence": 0.95}`
- First match wins (return immediately)

**2. Emphasis patterns (confidence 0.65-0.85):**
- CAPS_PATTERN: `r'\b[A-Z]{3,}\b'` -- words of 3+ uppercase letters
- MULTI_EXCLAIM_PATTERN: `r'!{2,}'` -- 2+ exclamation marks
- COMMON_ACRONYMS exclusion set (frozenset): AI, ML, API, URL, SQL, HTML, CSS, OK, NYC, USA, UK, CEO, CTO, HR, IT, PM, AM, PhD, MBA, GPS, ATM, FAQ, DIY, PDF, USB, RAM, CPU, GPU, NASA, FBI, CIA, NBA, NFL, NHL, MMA, UFC, BMW, AWS, GCP, IDE, OS, TV, AC, DC, DJ, MC, VR, AR, UN, EU, WHO, IRS, DMV
- Filter caps matches: `meaningful_caps = [w for w in caps_matches if w not in COMMON_ACRONYMS]`
- Scoring:
  - meaningful_caps AND exclamation_matches -> "frustrated", negative, confidence 0.85
  - len(meaningful_caps) >= 2 -> "emphatic", negative, confidence 0.70
  - exclamation_matches with 3+ marks -> "emphatic", neutral, confidence 0.65

**3. Topic sentiment (confidence 0.60):**
- HEAVY_TOPICS frozenset: death, funeral, cancer, diagnosis, divorce, breakup, fired, laid off, accident, surgery, hospital, bankruptcy, eviction, miscarriage, loss
- POSITIVE_TOPICS frozenset: promotion, engaged, wedding, pregnant, baby, graduated, accepted, hired, vacation, birthday, anniversary, achievement, award, raise
- Extract words from content: `set(re.findall(r'\b\w+\b', content.lower()))`
- Intersect with topic sets. If heavy match -> "distressed", negative, 0.60. If positive match -> "positive", positive, 0.60.

**Return None if no signal detected.**

The function signature and return type:
```python
def detect_emotion(content: str) -> Optional[Dict]:
    """Detect emotional context from text content.

    Returns None if no emotional signal detected, or a dict with:
    - emotion_label: str (e.g., "stressed", "excited", "frustrated")
    - valence: str ("positive", "negative", "neutral")
    - source: str ("explicit", "emphasis", "topic")
    - confidence: float (0.0-1.0)
    """
```

Use the `try/except ImportError` pattern for consistency with other modules, but since this module has no internal imports, a simple module-level implementation is fine.
  </action>
  <verify>
Run ALL of the following:

1. Module imports: `python -c "from daem0nmcp.emotion_detect import detect_emotion; print('Import OK')"`

2. Explicit detection: `python -c "from daem0nmcp.emotion_detect import detect_emotion; r = detect_emotion(\"I'm so stressed about work\"); assert r['emotion_label'] == 'stressed'; assert r['source'] == 'explicit'; assert r['confidence'] == 0.95; print('Explicit OK')"`

3. Emphasis detection: `python -c "from daem0nmcp.emotion_detect import detect_emotion; r = detect_emotion('THIS IS RIDICULOUS!!'); assert r['source'] == 'emphasis'; assert r['confidence'] == 0.85; print('Emphasis OK')"`

4. Topic detection: `python -c "from daem0nmcp.emotion_detect import detect_emotion; r = detect_emotion('My grandmother had surgery last week'); assert r['source'] == 'topic'; assert r['valence'] == 'negative'; print('Topic OK')"`

5. Acronym filtering: `python -c "from daem0nmcp.emotion_detect import detect_emotion; r = detect_emotion('I use the SQL API for my work'); assert r is None; print('Acronym filter OK')"`

6. No signal: `python -c "from daem0nmcp.emotion_detect import detect_emotion; r = detect_emotion('My sister lives in Portland'); assert r is None; print('No signal OK')"`

All 6 must pass.
  </verify>
  <done>
`detect_emotion()` correctly identifies explicit emotional statements at 0.95 confidence, emphasis patterns at 0.65-0.85 confidence, and topic sentiment at 0.60 confidence. Common acronyms are filtered. Returns None for neutral content.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire emotion enrichment into daem0n_remember and add tests</name>
  <files>daem0nmcp/tools/daem0n_remember.py, tests/test_daem0n_tools.py</files>
  <action>
**Modify `daem0nmcp/tools/daem0n_remember.py`:**

Add emotion detection import in the `try/except ImportError` block at the top:
```python
try:
    from ..emotion_detect import detect_emotion
except ImportError:
    from daem0nmcp.emotion_detect import detect_emotion
```

Add emotion enrichment AFTER the auto-detection validation pipeline (after the `if "auto" in tags:` block) but BEFORE the `ctx.memory_manager.remember()` call (currently line 124). This placement ensures:
- Auto-detected memories that pass validation get enriched
- Explicit memories (no "auto" tag) also get enriched
- Skipped/suggested memories never reach enrichment

The enrichment logic (insert between the auto-detection block and the `result = await ctx.memory_manager.remember(...)` call):
```python
# Emotion detection enrichment -- runs on ALL memories (explicit + auto-detected)
emotion = detect_emotion(content)
if emotion and emotion["confidence"] >= 0.60:
    # Add emotion category if not already present
    if "emotion" not in categories:
        categories = list(categories) + ["emotion"]
    # Add emotion metadata to tags
    tags.append(f"emotion:{emotion['emotion_label']}")
    tags.append(f"valence:{emotion['valence']}")
```

Note: `tags` was already normalized to a list earlier in the function (line 75: `tags = list(tags or [])`), and `categories` is already a list (normalized at line 64). The enrichment mutates both in-place before they're passed to `remember()`.

**Add tests to `tests/test_daem0n_tools.py`:**

Create a new test class `TestEmotionDetection` with the following tests:

1. `test_detect_explicit_positive` -- "I'm so excited about the trip" returns emotion_label="excited", valence="positive", source="explicit", confidence=0.95
2. `test_detect_explicit_negative` -- "I feel really anxious about the test" returns emotion_label="anxious", valence="negative", source="explicit", confidence=0.95
3. `test_detect_explicit_i_am_form` -- "I am stressed about deadlines" returns emotion_label="stressed"
4. `test_detect_emphasis_caps_and_exclaim` -- "WHY IS THIS HAPPENING!!" returns source="emphasis", confidence=0.85, valence="negative"
5. `test_detect_emphasis_multiple_caps` -- "STOP DOING THAT please" returns source="emphasis", confidence=0.70
6. `test_detect_emphasis_exclaim_only` -- "This is amazing!!!" returns source="emphasis", confidence=0.65
7. `test_detect_topic_heavy` -- "Dealing with the divorce paperwork" returns source="topic", valence="negative", emotion_label="distressed"
8. `test_detect_topic_positive` -- "Just got the promotion at work" returns source="topic", valence="positive"
9. `test_acronym_not_flagged` -- "Working with the API and SQL database" returns None
10. `test_no_emotion_neutral_content` -- "My cat's name is Whiskers" returns None
11. `test_enrichment_adds_emotion_category` -- Mock `daem0n_remember` call with emotionally-charged content (e.g., "User is stressed about the move"). Verify the stored memory has "emotion" in categories and "emotion:stressed" in tags. Use the same mocking pattern as existing `TestDaem0nRemember` tests: patch `get_user_context` and mock `ctx.memory_manager.remember`.
12. `test_enrichment_skips_neutral_content` -- Mock `daem0n_remember` call with neutral content (e.g., "User lives in Portland"). Verify "emotion" is NOT in categories.
13. `test_enrichment_preserves_existing_categories` -- Mock `daem0n_remember` with categories=["fact"] and emotional content. Verify result has BOTH "fact" and "emotion" in categories (not replaced).

For tests 1-10, import `detect_emotion` directly and test as a pure function.
For tests 11-13, follow the existing mocking patterns in `test_daem0n_tools.py` for testing `daem0n_remember`.

Run `pytest tests/test_daem0n_tools.py -x -q` to confirm all tests pass with no regressions.
  </action>
  <verify>
1. `pytest tests/test_daem0n_tools.py::TestEmotionDetection -v` -- all 13 tests pass
2. `pytest tests/test_daem0n_tools.py -x -q` -- no regressions in existing tests
3. `python -c "import inspect; from daem0nmcp.tools.daem0n_remember import daem0n_remember; src = inspect.getsource(daem0n_remember); assert 'detect_emotion' in src; assert 'emotion:' in src; print('Enrichment wired')"`
  </verify>
  <done>
Emotion detection is wired into `daem0n_remember` pipeline. All memories (explicit and auto-detected) are enriched with emotion category and tags when emotional signal is detected at >= 0.60 confidence. 13 tests pass covering all three detection methods, acronym filtering, enrichment integration, and category preservation.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/test_daem0n_tools.py -x -q` -- all tests pass, no regressions
2. `python -c "from daem0nmcp.emotion_detect import detect_emotion; print(detect_emotion('I am so worried about my mom'))"` -- returns dict with emotion_label="worried", source="explicit"
3. `python -c "from daem0nmcp.emotion_detect import detect_emotion; print(detect_emotion('Working on the API'))"` -- returns None
4. Emotion enrichment in `daem0n_remember` runs on all memories, not just auto-detected
5. Enrichment adds "emotion" to categories and "emotion:{label}" + "valence:{valence}" to tags
6. Existing auto-detection and explicit memory flows are unaffected
</verification>

<success_criteria>
- `detect_emotion()` handles all three CONV-03 detection methods: explicit statements, emphasis patterns, topic sentiment
- Common acronyms do not trigger false positive emphasis detection
- `daem0n_remember` enriches memories with emotion metadata before storage
- Both explicit and auto-detected memories receive emotion enrichment
- Enrichment adds to categories (not replaces) and appends to tags
- 13 new tests pass, 0 regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06-conversation-intelligence/06-01-SUMMARY.md`
</output>
