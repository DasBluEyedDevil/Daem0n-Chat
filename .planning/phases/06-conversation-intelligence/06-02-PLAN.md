---
phase: 06-conversation-intelligence
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - daem0nmcp/tools/daem0n_briefing.py
  - tests/test_daem0n_tools.py
autonomous: true

must_haves:
  truths:
    - "Briefing for a returning user includes a previous_session_summary with topics discussed, emotional tone, and unresolved threads from the prior session"
    - "Session boundaries are detected using a 2-hour time-gap heuristic on memory timestamps"
    - "Session summaries are 1-3 sentences and do not fabricate details beyond stored memory content"
    - "If the previous session had fewer than 2 memories, no summary is generated"
    - "Greeting guidance adjusts tone when previous session had negative emotional context"
  artifacts:
    - path: "daem0nmcp/tools/daem0n_briefing.py"
      provides: "Session summary generation and briefing integration"
      contains: "_build_previous_session_summary"
    - path: "tests/test_daem0n_tools.py"
      provides: "Tests for session boundary detection, summary generation, briefing integration"
  key_links:
    - from: "daem0nmcp/tools/daem0n_briefing.py (_build_previous_session_summary)"
      to: "briefing response previous_session_summary"
      via: "called in _build_user_briefing, result added to response dict"
      pattern: "previous_session_summary"
    - from: "daem0nmcp/tools/daem0n_briefing.py (_build_previous_session_summary)"
      to: "Memory table (created_at, categories, tags, content)"
      via: "SQL query grouping memories by time-gap heuristic"
      pattern: "SESSION_GAP_HOURS"
    - from: "daem0nmcp/tools/daem0n_briefing.py (_build_greeting_guidance)"
      to: "previous_session_summary emotional_tone"
      via: "greeting guidance uses emotional tone to adjust approach"
      pattern: "emotional_tone"
---

<objective>
Add session summarization to the briefing system so returning users get a concise summary of their previous conversation session, including topics discussed, emotional tone, and unresolved threads from that session.

Purpose: CONV-01 requires the system to generate conversation summaries at session end. Since MCP has no session-end event, summaries are generated at next-session briefing time from stored memory data. This is automatic, reliable, and requires no new tools.

Output: `_build_previous_session_summary()` in briefing, integration into `_build_user_briefing()`, tone-aware greeting guidance, tests.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-conversation-intelligence/06-RESEARCH.md
@.planning/phases/06-conversation-intelligence/06-01-SUMMARY.md
@daem0nmcp/tools/daem0n_briefing.py
@daem0nmcp/models.py
@daem0nmcp/temporal.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add session summary generation and integrate into briefing</name>
  <files>daem0nmcp/tools/daem0n_briefing.py</files>
  <action>
**Create `_build_previous_session_summary()` async function** in `daem0n_briefing.py`:

```python
async def _build_previous_session_summary(
    ctx, user_name: str
) -> Optional[Dict[str, Any]]:
```

Implementation:

1. **Query recent memories**: Fetch the most recent 30 memories for the user (not archived), ordered by `created_at` descending. Use `ctx.db_manager.get_session()` and `select(Memory).where(...)`.

2. **Session boundary detection** using 2-hour time-gap heuristic:
   - `SESSION_GAP_HOURS = 2` (module-level constant)
   - Walk through memories chronologically (they're ordered desc, so consecutive gaps go backward)
   - If gap between consecutive memories > 2 hours, start a new session cluster
   - Result: list of session clusters, each a list of Memory objects, newest session first

3. **Select previous session**:
   - If only 1 cluster exists, use it as the previous session (this IS the previous session; current session hasn't produced memories yet since briefing is called at start)
   - If 2+ clusters, use `sessions[1]` (second most recent, since `sessions[0]` could be the current session if memories from a just-prior conversation are within 2 hours)
   - Actually, since briefing runs at conversation START and no new memories have been stored yet, `sessions[0]` IS the previous session in most cases. Use `sessions[0]`.
   - Return None if the selected session has fewer than 2 memories

4. **Extract topics** (max 5, deduplicated):
   - For each memory in the session, use `_summarize(mem.content, 60)` to get a short summary
   - Skip duplicate summaries (case-insensitive comparison using a `seen` set)
   - Collect up to 5 topics

5. **Determine emotional tone**:
   - Scan session memories for those with "emotion" in categories
   - Also scan tags for "emotion:{label}" patterns
   - Collect emotion labels; pick the first one found (most recent = most relevant since memories ordered desc)
   - If no emotions found, `emotional_tone = None`

6. **Identify unresolved threads from that session**:
   - Scan session memories where category contains "concern" or "goal" and `outcome is None`
   - Use `_summarize(mem.content, 60)` for each, collect up to 3

7. **Build summary text** (1-3 sentences):
   - If topics: "You discussed {topic1}, {topic2}, and {topic3}." (or "You talked about {topic1}." for single)
   - If emotional_tone: "Emotional tone: {tone}."
   - If unresolved: "Left unresolved: {item1}; {item2}."
   - Return None if no summary parts generated

8. **Return dict**:
```python
{
    "summary": ". ".join(summary_parts) + ".",
    "topics": topics[:5],
    "emotional_tone": emotional_tone,
    "unresolved_from_session": unresolved[:3],
    "session_time": _humanize_timedelta(prev_session[0].created_at),
    "memory_count": len(prev_session),
}
```

**Integrate into `_build_user_briefing()`:**

After the existing emotional context gathering (section 5) and before building the response dict, add:

```python
# 6b. Previous session summary
previous_session_summary = await _build_previous_session_summary(ctx, user_name)
```

In the response dict assembly, add `previous_session_summary` only if not None:
```python
if previous_session_summary:
    response["previous_session_summary"] = previous_session_summary
```

**Enhance `_build_greeting_guidance()` with session tone awareness:**

Add a new parameter `previous_session_tone: Optional[str] = None` to `_build_greeting_guidance()`.

If `previous_session_tone` is a negative valence word (check against a small set: stressed, anxious, worried, frustrated, angry, upset, depressed, overwhelmed, scared, nervous, disappointed, exhausted, furious, miserable, devastated, annoyed, irritated, distressed), prepend to the guidance:
```
"The user's last conversation had a {tone} tone. Be warm and gentle in your greeting -- don't directly reference their emotions unless they bring it up."
```

Update the `_build_greeting_guidance()` call in `_build_user_briefing()` to pass `previous_session_tone=previous_session_summary.get("emotional_tone") if previous_session_summary else None`.
  </action>
  <verify>
Run ALL of the following:

1. Function exists and is async:
`python -c "import asyncio; from daem0nmcp.tools.daem0n_briefing import _build_previous_session_summary; assert asyncio.iscoroutinefunction(_build_previous_session_summary); print('Async function OK')"`

2. SESSION_GAP_HOURS constant:
`python -c "from daem0nmcp.tools.daem0n_briefing import SESSION_GAP_HOURS; assert SESSION_GAP_HOURS == 2; print('Constant OK')"`

3. Greeting guidance accepts new parameter:
`python -c "import inspect; from daem0nmcp.tools.daem0n_briefing import _build_greeting_guidance; sig = inspect.signature(_build_greeting_guidance); assert 'previous_session_tone' in sig.parameters; print('Parameter OK')"`

4. Integration wired in _build_user_briefing:
`python -c "import inspect; from daem0nmcp.tools.daem0n_briefing import _build_user_briefing; src = inspect.getsource(_build_user_briefing); assert '_build_previous_session_summary' in src; assert 'previous_session_summary' in src; print('Integration OK')"`

All 4 must pass.
  </verify>
  <done>
`_build_previous_session_summary()` generates a concise summary (1-3 sentences) of the previous conversation session using a 2-hour time-gap heuristic. Summary includes topics, emotional tone, and unresolved threads from that session. Integrated into briefing response and greeting guidance.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests for session summarization and briefing integration</name>
  <files>tests/test_daem0n_tools.py</files>
  <action>
Add a new test class `TestSessionSummary` to `tests/test_daem0n_tools.py` with the following tests.

For all tests requiring mock memories, create mock Memory objects with `created_at`, `content`, `categories`, `tags`, `outcome`, `archived`, and `user_name` attributes. Use `unittest.mock.MagicMock` or `unittest.mock.AsyncMock` as appropriate.

**Session boundary detection tests:**

1. `test_session_boundary_two_hour_gap` -- Create 6 mock memories: 3 within 30 minutes of each other (session A), then a 3-hour gap, then 3 more within 30 minutes (session B). Mock the DB query to return them. Call `_build_previous_session_summary()` and verify it identifies session A (the most recent cluster) correctly with 3 memories.

2. `test_session_boundary_no_gap_single_session` -- Create 5 mock memories all within 1 hour. Verify the function treats them as one session with 5 memories.

3. `test_session_too_few_memories_returns_none` -- Create 1 mock memory. Verify the function returns None (fewer than 2 memories).

**Summary content tests:**

4. `test_summary_extracts_topics` -- Create 4 mock memories with varied content. Verify the returned `topics` list contains summaries of those memories (up to 5).

5. `test_summary_deduplicates_topics` -- Create 3 mock memories where 2 have very similar content. Verify `topics` does not contain duplicates.

6. `test_summary_extracts_emotional_tone` -- Create mock memories where one has `categories=["context", "emotion"]` and `tags=["emotion:stressed", "valence:negative"]`. Verify `emotional_tone` is "stressed".

7. `test_summary_no_emotion_returns_none_tone` -- Create mock memories with no emotion category. Verify `emotional_tone` is None.

8. `test_summary_finds_unresolved_threads` -- Create mock memories including one with `categories=["concern"]` and `outcome=None`. Verify `unresolved_from_session` contains that memory's summary.

9. `test_summary_text_is_concise` -- Create mock memories. Verify the `summary` string is at most 3 sentences (count periods/sentence-ending punctuation).

**Briefing integration tests:**

10. `test_briefing_includes_session_summary` -- Full integration: mock a returning user with 5+ memories clustered as a session. Call `daem0n_briefing()` and verify the response contains `previous_session_summary` key with `topics` and `summary` fields.

11. `test_briefing_omits_summary_when_no_session` -- Mock a returning user with 0 memories. Verify `previous_session_summary` is NOT in the briefing response.

12. `test_greeting_guidance_tone_aware` -- Call `_build_greeting_guidance()` with `previous_session_tone="stressed"`. Verify the returned guidance contains "warm and gentle" or similar tone-adjustment language.

13. `test_greeting_guidance_no_tone_no_change` -- Call `_build_greeting_guidance()` with `previous_session_tone=None`. Verify the returned guidance does NOT contain tone-adjustment language.

For tests 10-11, follow the existing `TestDaem0nBriefing` mocking patterns with `patch("daem0nmcp.tools.daem0n_briefing.get_user_context")` and mock database sessions. Also mock `_build_previous_session_summary` if needed for isolation.

For tests 12-13, call `_build_greeting_guidance` directly with mock data.

Run `pytest tests/test_daem0n_tools.py -x -q` to confirm all tests pass with no regressions.
  </action>
  <verify>
1. `pytest tests/test_daem0n_tools.py::TestSessionSummary -v` -- all 13 tests pass
2. `pytest tests/test_daem0n_tools.py -x -q` -- no regressions in existing tests (including TestEmotionDetection from 06-01)
  </verify>
  <done>
13 tests pass covering session boundary detection (2-hour gap, single session, too-few memories), summary content (topics, deduplication, emotional tone, unresolved threads, conciseness), briefing integration (summary present/absent), and greeting guidance tone awareness.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/test_daem0n_tools.py -x -q` -- all tests pass, no regressions
2. Briefing for a returning user with multiple sessions includes `previous_session_summary`
3. Session summary has `topics`, `emotional_tone`, `unresolved_from_session`, `session_time`, `memory_count`
4. Summary text is 1-3 sentences
5. Sessions with <2 memories produce no summary
6. Greeting guidance mentions gentle approach when previous session tone was negative
7. No new MCP tools -- still 8 tools total
</verification>

<success_criteria>
- `_build_previous_session_summary()` generates summaries from memory data using 2-hour time-gap heuristic
- Summaries include topics discussed, emotional tone (from emotion-tagged memories), and unresolved threads
- Summary text is 1-3 sentences, never fabricates beyond stored memory content
- Briefing includes `previous_session_summary` field for returning users
- Greeting guidance adjusts tone when previous session had negative emotional context
- 13 new tests pass, 0 regressions
</success_criteria>

<output>
After completion, create `.planning/phases/06-conversation-intelligence/06-02-SUMMARY.md`
</output>
