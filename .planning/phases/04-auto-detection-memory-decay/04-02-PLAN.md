---
phase: 04-auto-detection-memory-decay
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - daem0nmcp/tools/daem0n_remember.py
  - daem0nmcp/tools/daem0n_briefing.py
  - tests/test_daem0n_tools.py
autonomous: true

must_haves:
  truths:
    - "daem0n_remember with tags=['auto'] validates content through noise filter before storing"
    - "daem0n_remember with tags=['auto'] checks for duplicate memories via recall semantic similarity"
    - "daem0n_remember returns status='skipped' for noise, duplicates, and low-confidence auto-detections"
    - "daem0n_remember returns status='suggested' for medium-confidence auto-detections (0.70-0.95)"
    - "daem0n_briefing response includes auto_detection_guidance instructing Claude on what/when to auto-detect"
    - "daem0n_remember tool description includes auto-detection usage guidance"
  artifacts:
    - path: "daem0nmcp/tools/daem0n_remember.py"
      provides: "Auto-detection validation, duplicate check, confidence parameter"
      contains: "validate_auto_memory"
    - path: "daem0nmcp/tools/daem0n_briefing.py"
      provides: "Auto-detection guidance in briefing response"
      contains: "auto_detection_guidance"
    - path: "tests/test_daem0n_tools.py"
      provides: "End-to-end auto-detection tests"
      contains: "TestAutoDetection"
  key_links:
    - from: "daem0nmcp/tools/daem0n_remember.py"
      to: "daem0nmcp/auto_detect.py"
      via: "import validate_auto_memory, DUPLICATE_SIMILARITY_THRESHOLD"
      pattern: "from.*auto_detect.*import.*validate_auto_memory"
    - from: "daem0nmcp/tools/daem0n_remember.py"
      to: "daem0nmcp/memory.py"
      via: "ctx.memory_manager.recall() for duplicate check"
      pattern: "recall.*duplicate|semantic_match.*DUPLICATE"
    - from: "daem0nmcp/tools/daem0n_briefing.py"
      to: "briefing response dict"
      via: "auto_detection_guidance key in response"
      pattern: "auto_detection_guidance"
---

<objective>
Wire auto-detection validation into daem0n_remember and add auto-detection guidance to daem0n_briefing.

Purpose: Plan 01 created the validation module and fixed decay. This plan integrates those pieces into the tool layer so that: (1) daem0n_remember validates auto-detected memories through the noise filter and duplicate detection before storing, (2) confidence routing returns appropriate statuses (auto_store / suggest / skipped), and (3) the briefing instructs Claude on what to auto-detect and how to use the confidence parameter.

Output: Enhanced daem0n_remember with auto-detection flow, enhanced daem0n_briefing with guidance, end-to-end tests.
</objective>

<execution_context>
@C:\Users\dasbl\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\dasbl\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-auto-detection-memory-decay/04-RESEARCH.md
@.planning/phases/04-auto-detection-memory-decay/04-01-SUMMARY.md
@daem0nmcp/tools/daem0n_remember.py
@daem0nmcp/tools/daem0n_briefing.py
@daem0nmcp/auto_detect.py (created in Plan 01)
@tests/test_daem0n_tools.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate auto-detection into daem0n_remember and enhance briefing</name>
  <files>daem0nmcp/tools/daem0n_remember.py, daem0nmcp/tools/daem0n_briefing.py</files>
  <action>
  1. MODIFY `daem0nmcp/tools/daem0n_remember.py`:

     a. Add `confidence: Optional[float] = None` parameter to daem0n_remember (after is_permanent, before user_id).

     b. Update the docstring to include auto-detection guidance:
     ```python
     """
     Store a memory about the user. Categories: fact, preference, interest,
     goal, concern, event, relationship, emotion, routine, context.
     Supports multiple categories per memory.

     For explicit user requests ("remember that..."):
     - Set is_permanent=True and include "explicit" in tags
     - Pick the most appropriate category from the content

     For auto-detected facts from natural conversation:
     - Include "auto" in tags
     - Set confidence (0.0-1.0): >=0.95 auto-stores, 0.70-0.95 suggests, <0.70 skips
     - DO NOT auto-remember: greetings, filler, small-talk, hypotheticals,
       temporary states ("I'm tired right now"), questions you asked
     - DO auto-remember: names, relationships, personal facts, preferences,
       goals, concerns, life events, routines, interests
     """
     ```

     c. Add auto-detection validation BEFORE the existing remember() call. After category validation and before `ctx = await get_user_context(...)`:
     ```python
     tags = list(tags or [])

     # Auto-detection validation pipeline
     if "auto" in tags:
         from ..auto_detect import validate_auto_memory, DUPLICATE_SIMILARITY_THRESHOLD
         from ..config import Settings

         effective_confidence = float(confidence) if confidence is not None else 0.5
         settings = Settings()
         validation = validate_auto_memory(content, effective_confidence, settings)

         if not validation["valid"]:
             return {"status": "skipped", "reason": validation["reason"]}

         # Duplicate detection: check if similar memory already exists
         ctx = await get_user_context(effective_user_id)
         try:
             existing = await ctx.memory_manager.recall(
                 topic=content,
                 limit=3,
                 user_id=ctx.user_id,
                 user_name=ctx.current_user,
             )
             for mem in existing.get("memories", []):
                 if mem.get("semantic_match", 0) >= DUPLICATE_SIMILARITY_THRESHOLD:
                     return {"status": "skipped", "reason": "duplicate", "existing_memory_id": mem["id"]}
         except Exception:
             pass  # If duplicate check fails, proceed with storage

         # Medium confidence: suggest confirmation instead of auto-storing
         if validation.get("action") == "suggest":
             return {
                 "status": "suggested",
                 "content": content,
                 "categories": categories if isinstance(categories, list) else [categories],
                 "confidence": effective_confidence,
                 "message": "Medium-confidence fact detected. Consider confirming with the user before storing.",
             }

         # High confidence: proceed to storage (fall through to existing logic)
     ```

     IMPORTANT: The `tags` variable is currently used as the raw parameter further down. Make sure you normalize it to a list (`tags = list(tags or [])`) early, BEFORE the auto-detection check AND before passing to `remember()`. Remove any duplicate normalization.

     IMPORTANT: The `ctx` variable is obtained via `get_user_context` -- if the auto path already created it for duplicate checking, don't call it again. Restructure so ctx is obtained once. The simplest approach: get ctx early (move the `ctx = await get_user_context(effective_user_id)` line before the auto-detection block), and use it in both the duplicate check and the remember call.

     d. Do NOT add auto-detection memories as permanent. Auto-detected memories follow category-based permanence rules (they do NOT get is_permanent=True forced). The existing is_permanent override logic should only apply when the caller explicitly sets is_permanent=True (which is the explicit-remember flow, not auto-detect).

  2. MODIFY `daem0nmcp/tools/daem0n_briefing.py`:

     a. Add `auto_detection_guidance` to the briefing response dict in `_build_user_briefing()`, just before the `return response` line (around line 294). Add it to the response dict:
     ```python
     response["auto_detection_guidance"] = (
         "Throughout this conversation, watch for personal information the user "
         "shares naturally. When you notice memorable facts, call daem0n_remember "
         "with tags=['auto'] and an appropriate confidence level.\n\n"
         "REMEMBER these (with tags=['auto']):\n"
         "- Names and relationships (sister Sarah, friend Mike)\n"
         "- Personal facts (lives in Portland, works as a nurse)\n"
         "- Preferences and opinions (hates cilantro, loves hiking)\n"
         "- Goals and aspirations (training for marathon, learning Spanish)\n"
         "- Concerns and worries (stressed about work, worried about mom)\n"
         "- Life events (got promoted, moving next month)\n"
         "- Routines and habits (morning coffee, Thursday yoga)\n"
         "- Interests and hobbies (into woodworking, reads sci-fi)\n\n"
         "DO NOT remember: greetings, filler, small-talk, hypotheticals, "
         "temporary states, questions you asked, your own suggestions.\n\n"
         "Confidence levels:\n"
         "- HIGH (>=0.95): User directly stated a fact. Auto-stores.\n"
         "- MEDIUM (0.70-0.95): User casually mentioned something. Returns suggestion.\n"
         "- LOW (<0.70): Vague or uncertain. Skipped automatically.\n\n"
         "Aim for 1-5 auto-detected memories per conversation. Be selective."
     )
     ```

     b. Also add a shorter version of the guidance to the first_session responses (both the brand-new-device and unnamed-user paths). After the existing `first_session_guidance`, add:
     ```python
     response["auto_detection_guidance"] = (
         "As you chat, watch for personal facts the user shares naturally. "
         "Call daem0n_remember with tags=['auto'] and confidence level (0.0-1.0) "
         "to store them. Names, relationships, preferences, goals, and interests "
         "are all worth remembering. Greetings and filler are not."
     )
     ```
     For the brand-new-device case (line ~86), add it to the return dict before the return statement.
     For the unnamed-user case (line ~115), add it to the briefing dict before returning.

  Handle the try/except ImportError pattern for auto_detect imports consistently with the rest of the tools module (check daem0n_remember.py's existing import pattern at the top).
  </action>
  <verify>
  - `python -c "from daem0nmcp.tools.daem0n_remember import daem0n_remember"` -- imports cleanly
  - `python -c "from daem0nmcp.tools.daem0n_briefing import daem0n_briefing"` -- imports cleanly
  - Inspect daem0n_remember source: has `confidence` parameter, has auto-detection validation block, has duplicate check
  - Inspect daem0n_briefing source: has `auto_detection_guidance` in response
  </verify>
  <done>
  - daem0n_remember has confidence parameter and auto-detection validation pipeline
  - Auto-detected memories go through noise filter, duplicate check, and confidence routing
  - Noise/duplicates/low-confidence return status="skipped" with reason
  - Medium confidence returns status="suggested" with content and message
  - High confidence proceeds to normal storage
  - daem0n_briefing includes auto_detection_guidance in all briefing responses
  </done>
</task>

<task type="auto">
  <name>Task 2: End-to-end tests for auto-detection flow</name>
  <files>tests/test_daem0n_tools.py</files>
  <action>
  Add a new test class `TestAutoDetection` to `tests/test_daem0n_tools.py`. Place it after the existing TestDaem0nRemember class.

  Follow the existing test patterns in the file -- look at how TestDaem0nRemember and TestDaem0nForget mock dependencies (they use `@pytest.fixture` with `patch` on `get_user_context`, `_default_user_id`, and the context's memory_manager). Match that exact mocking pattern.

  Tests to add:

  **Noise rejection tests:**
  - `test_auto_remember_rejects_greeting`: Call daem0n_remember with content="hello how are you", tags=["auto"], confidence=0.95. Assert result["status"] == "skipped" and result["reason"] == "noise_filter". The remember() method on memory_manager should NOT be called.

  - `test_auto_remember_rejects_short_content`: Call with content="dogs", tags=["auto"], confidence=0.95. Assert skipped with reason "too_short" or "too_few_words".

  **Confidence routing tests:**
  - `test_auto_remember_high_confidence_stores`: Call with content="User's sister Sarah lives in Portland Oregon area", tags=["auto"], confidence=0.98, categories="relationship". Mock recall() to return empty memories (no duplicates). Assert that memory_manager.remember() WAS called (the memory was stored). Assert result contains the remember() return value (not a skipped/suggested status).

  - `test_auto_remember_medium_confidence_suggests`: Call with content="User mentioned going to the gym regularly these days", tags=["auto"], confidence=0.80, categories="routine". Assert result["status"] == "suggested" and result["confidence"] == 0.80. Assert remember() was NOT called.

  - `test_auto_remember_low_confidence_skips`: Call with content="User might have some interest in painting or drawing", tags=["auto"], confidence=0.40, categories="interest". Assert result["status"] == "skipped" and result["reason"] == "low_confidence". Assert remember() was NOT called.

  **Duplicate detection test:**
  - `test_auto_remember_skips_duplicate`: Call with content="User's sister is named Sarah", tags=["auto"], confidence=0.96, categories="relationship". Mock recall() to return a memory with semantic_match=0.90 (above 0.85 threshold). Assert result["status"] == "skipped" and result["reason"] == "duplicate". Assert remember() was NOT called.

  **Explicit remember still works test:**
  - `test_explicit_remember_bypasses_auto_validation`: Call with content="My favorite color is blue", tags=["explicit"], is_permanent=True, categories="preference". Assert that NO auto-detection validation happens (no noise filter, no duplicate check). Assert remember() WAS called normally. This confirms the auto-detection pipeline only activates when "auto" is in tags.

  **Briefing guidance test:**
  - `test_briefing_includes_auto_detection_guidance`: Call daem0n_briefing and assert `"auto_detection_guidance"` key exists in the response dict and contains the string `"tags=['auto']"`.

  Run: `python -m pytest tests/test_daem0n_tools.py -v`
  </action>
  <verify>
  - `python -m pytest tests/test_daem0n_tools.py::TestAutoDetection -v` -- all new tests pass
  - `python -m pytest tests/test_daem0n_tools.py -v` -- all tests pass (existing + new, 0 regressions)
  - `python -m pytest tests/test_auto_detect.py -v` -- Plan 01 tests still pass
  </verify>
  <done>
  - TestAutoDetection class has 8+ tests covering noise rejection, confidence routing, duplicate detection, explicit bypass, and briefing guidance
  - All existing tests pass without regression
  - End-to-end auto-detection flow is verified: noise filtered -> duplicates checked -> confidence routed -> stored or suggested or skipped
  </done>
</task>

</tasks>

<verification>
1. `python -c "from daem0nmcp.tools.daem0n_remember import daem0n_remember"` -- no import errors
2. `python -c "from daem0nmcp.tools.daem0n_briefing import daem0n_briefing"` -- no import errors
3. `python -m pytest tests/test_daem0n_tools.py -v` -- all tests pass including new TestAutoDetection
4. `python -m pytest tests/test_auto_detect.py -v` -- Plan 01 tests still pass
5. `python -m pytest tests/test_similarity.py::TestMemoryDecay -v` -- Plan 01 decay tests still pass
</verification>

<success_criteria>
- daem0n_remember validates auto-detected memories (tags=["auto"]) through noise filter, duplicate detection, and confidence routing before storage
- High-confidence (>=0.95) auto-detections are stored normally
- Medium-confidence (0.70-0.95) auto-detections return "suggested" status for Claude to optionally confirm with user
- Low-confidence (<0.70), noisy, short, and duplicate content is rejected with "skipped" status
- Explicit remember (tags=["explicit"]) bypasses all auto-detection validation
- Briefing includes auto_detection_guidance instructing Claude on what to auto-detect
- All existing tests pass without regression
- Tool count remains at 8 (no new tools added)
</success_criteria>

<output>
After completion, create `.planning/phases/04-auto-detection-memory-decay/04-02-SUMMARY.md`
</output>
